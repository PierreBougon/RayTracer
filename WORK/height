src/debug.c:  dprintf(2, "\n___POSX = %d\n___POSY = %d\n\n======\n", pos->x, pos->y);
src/debug.c:	printf("#TRUE -> %d\n", i);
src/debug.c:	printf("#FALSE -> %d\n", i);
src/engine/setup_noise.c:  *r0 = t - (int)t;
src/engine/setup_noise.c:  *r1 = *r0 - 1.0;
src/engine/display_objects.c:  s->hit.limited = 0;
src/engine/display_objects.c:  shape = (t_sphere *)obj->datas;
src/engine/display_objects.c:  if (get_simple_inter(s, s->ray.vct, &s->ray.new_eye) == 0)
src/engine/display_objects.c:      end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:      end_rotation(&s->rotation, &s->hit.simple_inter1, &shape->rot);
src/engine/display_objects.c:      rotation(&s->rotation, &s->hit.simple_inter1, &shape->rot);
src/engine/display_objects.c:      shape->simple_inter1 = s->hit.simple_inter1;
src/engine/display_objects.c:      shape->simple_inter2 = s->hit.simple_inter2;
src/engine/display_objects.c:      shape->k1 = s->hit.k1;
src/engine/display_objects.c:      shape->k2 = s->hit.k2;
src/engine/display_objects.c:      shape->norm = s->hit.norm;
src/engine/display_objects.c:      update_hit_list(s, shape, 2, s->hit.k1);
src/engine/display_objects.c:    end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:  s->hit.limited = 0;
src/engine/display_objects.c:  shape = (t_cylinder *)obj->datas;
src/engine/display_objects.c:  if (get_simple_inter(s, s->ray.vct, &s->ray.new_eye) == 0)
src/engine/display_objects.c:      end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:	  shape->simple_inter1 = s->hit.simple_inter1;
src/engine/display_objects.c:	  shape->simple_inter2 = s->hit.simple_inter2;
src/engine/display_objects.c:	  shape->k1 = s->hit.k1;
src/engine/display_objects.c:	  shape->k2 = s->hit.k2;
src/engine/display_objects.c:	  shape->norm = s->hit.norm;
src/engine/display_objects.c:	  shape->limited = s->hit.limited;
src/engine/display_objects.c:	  update_hit_list(s, shape, 3, s->hit.k1);
src/engine/display_objects.c:    end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:  s->hit.limited = 0;
src/engine/display_objects.c:  shape = (t_cone *)obj->datas;
src/engine/display_objects.c:  if (get_simple_inter(s, s->ray.vct, &s->ray.new_eye) == 0)
src/engine/display_objects.c:      end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:	  shape->simple_inter1 = s->hit.simple_inter1;
src/engine/display_objects.c:	  shape->simple_inter2 = s->hit.simple_inter2;
src/engine/display_objects.c:	  shape->k1 = s->hit.k1;
src/engine/display_objects.c:	  shape->k2 = s->hit.k2;
src/engine/display_objects.c:	  shape->norm = s->hit.norm;
src/engine/display_objects.c:	  shape->limited = s->hit.limited;
src/engine/display_objects.c:	  update_hit_list(s, shape, 4, s->hit.k1);
src/engine/display_objects.c:    end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:  s->hit.limited = 0;
src/engine/display_objects.c:  shape = (t_plan *)obj->datas;
src/engine/display_objects.c:  if (get_simple_inter(s, s->ray.vct, &s->ray.new_eye) == 0)
src/engine/display_objects.c:      end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:	  shape->simple_inter1 = s->hit.simple_inter1;
src/engine/display_objects.c:	  shape->simple_inter2 = s->hit.simple_inter2;
src/engine/display_objects.c:	  shape->k1 = s->hit.k1;
src/engine/display_objects.c:	  shape->k2 = s->hit.k2;
src/engine/display_objects.c:	  shape->norm = s->hit.norm;
src/engine/display_objects.c:	  update_hit_list(s, shape, 5, s->hit.k1);
src/engine/display_objects.c:    end_rotation(&s->rotation, s->ray.vct, &shape->rot);
src/engine/display_objects.c:  s->hit.limited = 0;
src/engine/display_objects.c:  shape = (t_box *)obj->datas;
src/engine/update_hit_list.c:  if (s->hit.k1 > 0.000001 || s->hit.k2 > 0.000001)
src/engine/update_hit_list.c:      if (s->obj_hit == NULL)
src/engine/update_hit_list.c:	  if ((s->obj_hit = create_obj_list()) == NULL)
src/engine/update_hit_list.c:	    return (-1);
src/engine/update_hit_list.c:      if (add_obj_elem(s->obj_hit) == -1)
src/engine/update_hit_list.c:	return (-1);
src/engine/update_hit_list.c:      it = s->obj_hit;
src/engine/update_hit_list.c:      it->real = 1;
src/engine/update_hit_list.c:      while (it->next != NULL)
src/engine/update_hit_list.c:	it = it->next;
src/engine/update_hit_list.c:      it->datas = shape;
src/engine/update_hit_list.c:      it->type = type;
src/engine/update_hit_list.c:      it->k = k;
src/engine/shade.c:  add = diffuse_light(s, s->obj_hit->next);
src/engine/shade.c:      add = add * light->intensity * s->hit.kd;
src/engine/shade.c:      add += (specular_light(s, s->ray.vct) * light->intensity * s->hit.ks);
src/engine/shade.c:      *light_color = add_light_color(*light_color, light->color);
src/engine/shade.c:  i = get_soft_intensity(s, itab) + s->opt.ambient * s->hit.ka;
src/engine/shade.c:  s->final_color = apply_b(s->final_color, light_color, s->hit.brightness, i);
src/engine/shade.c:  if (s->shade.shadow.coef > 1.0)
src/engine/shade.c:    coef = s->shade.shadow.coef;
src/engine/shade.c:  itab[s->shade.diff] = (apply_light(s, light, light_color) * (1.0 - coef));
src/engine/shade.c:  s->shade.diff++;
src/engine/shade.c:  it = s->obj;
src/engine/shade.c:  init_itab(s->shade.itab);
src/engine/shade.c:      if (it->type == 1)
src/engine/shade.c:	  s->shade.diff = 0;
src/engine/shade.c:	  light = (t_light *)it->datas;
src/engine/shade.c:	  while (s->shade.diff < s->opt.nb_rays_ss)
src/engine/shade.c:	      fill_itab(s, light, &light_color, s->shade.itab);
src/engine/shade.c:      it = it->next;
src/engine/shade.c:  get_final_color(s, light_color, s->shade.itab);
src/engine/load_cone.c:  s->pos.x = my_getnbr((char *)field);
src/engine/load_cone.c:  s->pos.y = my_getnbr((char *)field);
src/engine/load_cone.c:  s->pos.z = my_getnbr((char *)field);
src/engine/load_cone.c:  s->rot.x = my_getnbr((char *)field);
src/engine/load_cone.c:  s->rot.y = my_getnbr((char *)field);
src/engine/load_cone.c:  s->rot.z = my_getnbr((char *)field);
src/engine/load_cone.c:  s->height = my_getnbr((char *)field);
src/engine/load_cone.c:  s->angle = 90 - my_getnbr((char *)field);
src/engine/load_cone.c:  if (s->angle >= 90 || s->angle <= 0)
src/engine/load_cone.c:  s->real = my_getnbr((char *)field);
src/engine/load_cone.c:  s->refraction = atof((char *)field);
src/engine/load_cone.c:  if (s->real == 1)
src/engine/load_cone.c:  s->ka = (double)my_getnbr((char *)field) / 100;
src/engine/load_cone.c:  s->kd = (double)my_getnbr((char *)field) / 100;
src/engine/load_cone.c:  s->ks = (double)my_getnbr((char *)field) / 100;
src/engine/load_cone.c:  s->brightness = (double)my_getnbr((char *)field) / 100;
src/engine/load_cone.c:  s->reflection = (double)my_getnbr((char *)field) / 100;
src/engine/load_cone.c:  s->tex_type = my_getnbr((char *)field);
src/engine/load_cone.c:  s->opacity = my_getnbr((char *)field);
src/engine/load_cone.c:  s->color1.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_cone.c:  s->color2.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_cone.c:  if (s->tex_type == IMAGE)
src/engine/load_cone.c:      s->tex1_name = my_strdup((char *)field);
src/engine/load_cone.c:      if ((s->texture2 = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_cone.c:      s->tex2_name = my_strdup((char *)field);
src/engine/load_cone.c:      if ((s->texture1 = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_cone.c:    return (-1);
src/engine/load_cone.c:  if (rt->obj == NULL)
src/engine/load_cone.c:      if ((rt->obj = create_obj_list()) == NULL)
src/engine/load_cone.c:	return (-1);
src/engine/load_cone.c:      if (add_obj_elem(rt->obj) == -1)
src/engine/load_cone.c:	return (-1);
src/engine/load_cone.c:  it = rt->obj;
src/engine/load_cone.c:  while (it->next != NULL)
src/engine/load_cone.c:    it = it->next;
src/engine/load_cone.c:  it->type = 4;
src/engine/load_cone.c:  if (load_cone_datas(s, ini, scope) == -1)
src/engine/load_cone.c:    return (-1);
src/engine/load_cone.c:  it->datas = s;
src/engine/get_refracted_vec.c:  if (f->sin_theta2 > 0.99999)
src/engine/get_refracted_vec.c:      f->reflectance = 1;
src/engine/get_refracted_vec.c:      f->cos_theta2 = 0;
src/engine/get_refracted_vec.c:      r = pow((f->n2 - 1.0), 2) / pow((f->n2 + 1.0), 2);
src/engine/get_refracted_vec.c:      f->reflectance = r + (1.0 - r) * pow((1.0 - f->cos_theta1), 5);
src/engine/get_refracted_vec.c:      f->transmittance = 1.0 - f->reflectance;
src/engine/get_refracted_vec.c:  f->cos_theta2 = sqrt(1 - f->sin_theta2 * f->sin_theta2);
src/engine/get_refracted_vec.c:  f->refraction_vct.x = ((f->n1 / f->n2) * nvct->x)
src/engine/get_refracted_vec.c:    + ((f->n1 / f->n2) * f->cos_theta1 - f->cos_theta2) * nnorm->x;
src/engine/get_refracted_vec.c:  f->refraction_vct.y = ((f->n1 / f->n2) * nvct->y)
src/engine/get_refracted_vec.c:    + ((f->n1 / f->n2) * f->cos_theta1 - f->cos_theta2) * nnorm->y;
src/engine/get_refracted_vec.c:  f->refraction_vct.z = ((f->n1 / f->n2) * nvct->z)
src/engine/get_refracted_vec.c:    + ((f->n1 / f->n2) * f->cos_theta1 - f->cos_theta2) * nnorm->z;
src/engine/get_refracted_vec.c:  f->reflection_vct.x = 2 * f->cos_theta1 * nnorm->x + nvct->x;
src/engine/get_refracted_vec.c:  f->reflection_vct.y = 2 * f->cos_theta1 * nnorm->y + nvct->y;
src/engine/get_refracted_vec.c:  f->reflection_vct.z = 2 * f->cos_theta1 * nnorm->z + nvct->z;
src/engine/get_refracted_vec.c:  len = sqrt(pow(s->ray.vct->x, 2) + pow(s->ray.vct->y, 2)
src/engine/get_refracted_vec.c:	     + pow(s->ray.vct->z, 2));
src/engine/get_refracted_vec.c:  nvct.x = s->ray.vct->x / len;
src/engine/get_refracted_vec.c:  nvct.y = s->ray.vct->y / len;
src/engine/get_refracted_vec.c:  nvct.z = s->ray.vct->z / len;
src/engine/get_refracted_vec.c:  len = sqrt(pow(norm->x, 2) + pow(norm->y, 2) + pow(norm->z, 2));
src/engine/get_refracted_vec.c:  nnorm.x = norm->x / len;
src/engine/get_refracted_vec.c:  nnorm.y = norm->y / len;
src/engine/get_refracted_vec.c:  nnorm.z = norm->z / len;
src/engine/get_refracted_vec.c:  f.cos_theta1 = - ((nnorm.x * nvct.x) + (nnorm.y * nvct.y)
src/engine/get_refracted_vec.c:  f.sin_theta1 = sqrt(1 - f.cos_theta1 * f.cos_theta1);
src/engine/soft_shadows.c:  while (j < s->opt.nb_rays_ss)
src/engine/soft_shadows.c:  i = i / (double)s->opt.nb_rays_ss;
src/engine/inter_tore.c:  return (CARRE(CARRE(s->ray.vct->x) + CARRE(s->ray.vct->y) +
src/engine/inter_tore.c:		CARRE(s->ray.vct->z)));
src/engine/inter_tore.c:  return (2 * ((CARRE(s->ray.vct->x) + CARRE(s->ray.vct->y) +
src/engine/inter_tore.c:		CARRE(s->ray.vct->z)) *
src/engine/inter_tore.c:	       (1 + ((s->ray.new_eye.x * s->ray.vct->x) +
src/engine/inter_tore.c:		     (s->ray.new_eye.y * s->ray.vct->y) +
src/engine/inter_tore.c:		     (s->ray.new_eye.z * s->ray.vct->z)))));
src/engine/inter_tore.c:  return (4 * (((s->ray.new_eye.x * s->ray.vct->x) +
src/engine/inter_tore.c:		(s->ray.new_eye.y * s->ray.vct->y) +
src/engine/inter_tore.c:		(s->ray.new_eye.z * s->ray.vct->z)) +
src/engine/inter_tore.c:	       ((CARRE(s->ray.vct->x) + CARRE(s->ray.vct->y) +
src/engine/inter_tore.c:		 CARRE(s->ray.vct->z)) *
src/engine/inter_tore.c:		((2 * CARRE(s->ray.new_eye.x)) +
src/engine/inter_tore.c:		 (2 * CARRE(s->ray.new_eye.y)) +
src/engine/inter_tore.c:		 (2 * CARRE(s->ray.new_eye.z)) +
src/engine/inter_tore.c:		 (2 * CARRE(tore->dist)) - (2 * CARRE(tore->rad))))));
src/engine/inter_tore.c:  return ((-4 * CARRE(tore->dist)) *
src/engine/inter_tore.c:	  (CARRE(s->ray.vct->x) + CARRE(s->ray.vct->y)) +
src/engine/inter_tore.c:	  ((s->ray.new_eye.x * s->ray.vct->x) +
src/engine/inter_tore.c:	   (s->ray.new_eye.y * s->ray.vct->y) +
src/engine/inter_tore.c:	   (s->ray.new_eye.z * s->ray.vct->z)) *
src/engine/inter_tore.c:	  ((4 * CARRE(s->ray.new_eye.x)) + (4 * CARRE(s->ray.new_eye.y)) +
src/engine/inter_tore.c:	   (4 * CARRE(s->ray.new_eye.z)) + (4 * CARRE(tore->dist)) -
src/engine/inter_tore.c:	   (4 * CARRE(tore->rad))));
src/engine/inter_tore.c:  return (CARRE((CARRE(s->ray.new_eye.x) + CARRE(s->ray.new_eye.y) +
src/engine/inter_tore.c:		 CARRE(s->ray.new_eye.z) + CARRE(tore->dist) +
src/engine/inter_tore.c:		 CARRE(tore->rad))) -
src/engine/inter_tore.c:	  ((4 * CARRE(tore->dist)) *
src/engine/inter_tore.c:	   (CARRE(s->ray.new_eye.x) +
src/engine/inter_tore.c:	    CARRE(s->ray.new_eye.y) +
src/engine/inter_tore.c:	    (2 * s->ray.new_eye.x * s->ray.vct->x) +
src/engine/inter_tore.c:	    (2 * s->ray.new_eye.y * s->ray.vct->y))));
src/engine/inter_tore.c:  s->ray.new_eye.x = s->ray.eye.x - tore->pos.x;
src/engine/inter_tore.c:  s->ray.new_eye.y = s->ray.eye.y - tore->pos.y;
src/engine/inter_tore.c:  s->ray.new_eye.z = s->ray.eye.z - tore->pos.z;
src/engine/inter_tore.c:  rotation(&s->rotation, s->ray.vct, &tore->rot);
src/engine/inter_tore.c:  rotation(&s->rotation, &s->ray.new_eye, &tore->rot);
src/engine/skybox.c:  color = (t_color *)img->pixels;
src/engine/skybox.c:  u = u * img->clipable.clip_width;
src/engine/skybox.c:  v = v * img->clipable.clip_height;
src/engine/skybox.c:  s->final_color = color[img->clipable.clip_width * (int)v + (int)u];
src/engine/skybox.c:  if (vct->x > 0.0)
src/engine/skybox.c:      s->final_color.full = 0xFF0000FF;
src/engine/skybox.c:		   (vct->z / vct->x + 1.0) * 0.5,
src/engine/skybox.c:		   1.0 - (vct->y / vct->x + 1.0) * 0.5,
src/engine/skybox.c:		   s->opt.skybox_right);
src/engine/skybox.c:      s->final_color.full = 0xFF0000FF;
src/engine/skybox.c:		   (vct->z / vct->x + 1.0) * 0.5,
src/engine/skybox.c:		   (vct->y / vct->x + 1.0) * 0.5,
src/engine/skybox.c:		   s->opt.skybox_left);
src/engine/skybox.c:  if (vct->y > 0.0)
src/engine/skybox.c:		 1.0 - (vct->x / vct->y + 1.0) * 0.5,
src/engine/skybox.c:		 (vct->z / vct->y + 1.0) * 0.5,
src/engine/skybox.c:		 s->opt.skybox_up);
src/engine/skybox.c:		 (vct->x / vct->y + 1.0) * 0.5,
src/engine/skybox.c:		 1.0 - (vct->z / vct->y + 1.0) * 0.5,
src/engine/skybox.c:		 s->opt.skybox_down);
src/engine/skybox.c:  if (vct->z > 0.0)
src/engine/skybox.c:		   1.0 - (vct->x / vct->z + 1.0) * 0.5,
src/engine/skybox.c:		   1.0 - (vct->y / vct->z + 1.0) * 0.5,
src/engine/skybox.c:		   s->opt.skybox_forward);
src/engine/skybox.c:		   1.0 - (vct->x / vct->z + 1.0) * 0.5,
src/engine/skybox.c:		   (vct->y / vct->z + 1.0) * 0.5,
src/engine/skybox.c:		   s->opt.skybox_backward);
src/engine/skybox.c:  if (s->opt.skybox == 0)
src/engine/skybox.c:      s->final_color.full = BLACK;
src/engine/skybox.c:  if (fabs(vct->x) >= fabs(vct->y) && fabs(vct->x) >= fabs(vct->z))
src/engine/skybox.c:  else if (fabs(vct->y) >= fabs(vct->x) && fabs(vct->y) >= fabs(vct->z))
src/engine/update_real_hit_list.c:  it = s->obj_hit;
src/engine/update_real_hit_list.c:  while (it != NULL && it->real == 1)
src/engine/update_real_hit_list.c:    it = it->next;
src/engine/update_real_hit_list.c:    it->real = 1;
src/engine/update_real_hit_list.c:  it = s->obj_hit;
src/engine/update_real_hit_list.c:  if (s->obj_hit->next == NULL)
src/engine/update_real_hit_list.c:  while (it->next != NULL && it->next->next != NULL)
src/engine/update_real_hit_list.c:    it = it->next;
src/engine/update_real_hit_list.c:  while (it->next->real == 0)
src/engine/update_real_hit_list.c:      bunny_free(it->next);
src/engine/update_real_hit_list.c:      it->next = NULL;
src/engine/update_real_hit_list.c:      it = it->prev;
src/engine/specular_light.c:  s->hit.r.x = 2 * s->hit.cos_theta * s->hit.nnorm.x + s->shade.nvct.x;
src/engine/specular_light.c:  s->hit.r.y = 2 * s->hit.cos_theta * s->hit.nnorm.y + s->shade.nvct.y;
src/engine/specular_light.c:  s->hit.r.z = 2 * s->hit.cos_theta * s->hit.nnorm.z + s->shade.nvct.z;
src/engine/specular_light.c:  len = sqrt(pow(vision->x, 2) + pow(vision->y, 2) + pow(vision->z, 2));
src/engine/specular_light.c:  nvision.x = - vision->x / len;
src/engine/specular_light.c:  nvision.y = - vision->y / len;
src/engine/specular_light.c:  nvision.z = - vision->z / len;
src/engine/specular_light.c:  a = (nvision.x * s->hit.r.x)
src/engine/specular_light.c:    + (nvision.y * s->hit.r.y)
src/engine/specular_light.c:    + (nvision.z * s->hit.r.z);
src/engine/set_hit_values.c:  sphere = obj->datas;
src/engine/set_hit_values.c:  s->hit.k1 = sphere->k1;
src/engine/set_hit_values.c:  s->hit.k2 = sphere->k2;
src/engine/set_hit_values.c:  s->hit.simple_inter1 = sphere->simple_inter1;
src/engine/set_hit_values.c:  s->hit.simple_inter2 = sphere->simple_inter2;
src/engine/set_hit_values.c:  s->hit.norm = sphere->norm;
src/engine/set_hit_values.c:  s->hit.brightness = sphere->brightness;
src/engine/set_hit_values.c:  s->hit.ka = sphere->ka;
src/engine/set_hit_values.c:  s->hit.kd = sphere->kd;
src/engine/set_hit_values.c:  s->hit.ks = sphere->ks;
src/engine/set_hit_values.c:  s->hit.reflection = sphere->reflection;
src/engine/set_hit_values.c:  s->hit.opacity = sphere->opacity;
src/engine/set_hit_values.c:  s->hit.n2 = sphere->refraction;
src/engine/set_hit_values.c:  s->hit.limited = 0;
src/engine/set_hit_values.c:  s->final_color = sphere->color1;
src/engine/set_hit_values.c:  s->hit.color1 = sphere->color1;
src/engine/set_hit_values.c:  s->hit.color2 = sphere->color2;
src/engine/set_hit_values.c:  s->hit.tex_type = sphere->tex_type;
src/engine/set_hit_values.c:  s->hit.texture1 = sphere->texture;
src/engine/set_hit_values.c:  cylinder = obj->datas;
src/engine/set_hit_values.c:  s->hit.k1 = cylinder->k1;
src/engine/set_hit_values.c:  s->hit.k2 = cylinder->k2;
src/engine/set_hit_values.c:  s->hit.simple_inter1 = cylinder->simple_inter1;
src/engine/set_hit_values.c:  s->hit.simple_inter2 = cylinder->simple_inter2;
src/engine/set_hit_values.c:  s->hit.norm = cylinder->norm;
src/engine/set_hit_values.c:  s->hit.brightness = cylinder->brightness;
src/engine/set_hit_values.c:  s->hit.ka = cylinder->ka;
src/engine/set_hit_values.c:  s->hit.kd = cylinder->kd;
src/engine/set_hit_values.c:  s->hit.ks = cylinder->ks;
src/engine/set_hit_values.c:  s->hit.opacity = cylinder->opacity;
src/engine/set_hit_values.c:  s->hit.reflection = cylinder->reflection;
src/engine/set_hit_values.c:  s->hit.n2 = cylinder->refraction;
src/engine/set_hit_values.c:  s->hit.limited = cylinder->limited;
src/engine/set_hit_values.c:  s->final_color = cylinder->color1;
src/engine/set_hit_values.c:  if (s->hit.limited == 0)
src/engine/set_hit_values.c:      s->hit.color1 = cylinder->color1;
src/engine/set_hit_values.c:      s->hit.color2 = cylinder->color2;
src/engine/set_hit_values.c:  if (s->hit.limited == 1)
src/engine/set_hit_values.c:      s->hit.color1 = cylinder->color2;
src/engine/set_hit_values.c:      s->hit.color2 = cylinder->color1;
src/engine/set_hit_values.c:  s->hit.tex_type = cylinder->tex_type;
src/engine/set_hit_values.c:  s->hit.texture1 = cylinder->texture1;
src/engine/set_hit_values.c:  s->hit.texture2 = cylinder->texture2;
src/engine/set_hit_values.c:  if (s->hit.limited == 0)
src/engine/set_hit_values.c:  cone = obj->datas;
src/engine/set_hit_values.c:  s->hit.k1 = cone->k1;
src/engine/set_hit_values.c:  s->hit.k2 = cone->k2;
src/engine/set_hit_values.c:  s->hit.simple_inter1 = cone->simple_inter1;
src/engine/set_hit_values.c:  s->hit.simple_inter2 = cone->simple_inter2;
src/engine/set_hit_values.c:  s->hit.norm = cone->norm;
src/engine/set_hit_values.c:  s->hit.brightness = cone->brightness;
src/engine/set_hit_values.c:  s->hit.ka = cone->ka;
src/engine/set_hit_values.c:  s->hit.kd = cone->kd;
src/engine/set_hit_values.c:  s->hit.ks = cone->ks;
src/engine/set_hit_values.c:  s->hit.reflection = cone->reflection;
src/engine/set_hit_values.c:  s->hit.opacity = cone->opacity;
src/engine/set_hit_values.c:  s->hit.n2 = cone->refraction;
src/engine/set_hit_values.c:  s->hit.limited = cone->limited;
src/engine/set_hit_values.c:  s->final_color = cone->color1;
src/engine/set_hit_values.c:  s->hit.color1 = cone->color1;
src/engine/set_hit_values.c:  s->hit.color2 = cone->color2;
src/engine/set_hit_values.c:  s->hit.tex_type = cone->tex_type;
src/engine/set_hit_values.c:  s->hit.texture1 = cone->texture1;
src/engine/set_hit_values.c:  s->hit.texture2 = cone->texture2;
src/engine/set_hit_values.c:  plan = obj->datas;
src/engine/set_hit_values.c:  s->hit.k1 = plan->k1;
src/engine/set_hit_values.c:  s->hit.k2 = plan->k2;
src/engine/set_hit_values.c:  s->hit.simple_inter1 = plan->simple_inter1;
src/engine/set_hit_values.c:  s->hit.simple_inter2 = plan->simple_inter2;
src/engine/set_hit_values.c:  s->hit.norm = plan->norm;
src/engine/set_hit_values.c:  s->hit.brightness = plan->brightness;
src/engine/set_hit_values.c:  s->hit.ka = plan->ka;
src/engine/set_hit_values.c:  s->hit.kd = plan->kd;
src/engine/set_hit_values.c:  s->hit.ks = plan->ks;
src/engine/set_hit_values.c:  s->hit.reflection = plan->reflection;
src/engine/set_hit_values.c:  s->hit.opacity = plan->opacity;
src/engine/set_hit_values.c:  s->hit.n2 = plan->refraction;
src/engine/set_hit_values.c:  s->hit.color1 = plan->color1;
src/engine/set_hit_values.c:  s->hit.color2 = plan->color2;
src/engine/set_hit_values.c:  s->final_color = plan->color1;
src/engine/set_hit_values.c:  s->hit.tex_type = plan->tex_type;
src/engine/set_hit_values.c:  s->hit.texture1 = plan->texture;
src/engine/set_hit_values.c:  s->ftabs.hit_ftab[0] = &set_hit_values_from_sphere;
src/engine/set_hit_values.c:  s->ftabs.hit_ftab[1] = &set_hit_values_from_cylinder;
src/engine/set_hit_values.c:  s->ftabs.hit_ftab[2] = &set_hit_values_from_cone;
src/engine/set_hit_values.c:  s->ftabs.hit_ftab[3] = &set_hit_values_from_plan;
src/engine/set_hit_values.c:  s->ftabs.hit_ftab[obj->type - 2](s, obj);
src/engine/inters.c:  s->ray.new_eye.x = (double)(s->ray.eye.x - plan->pos.x);
src/engine/inters.c:  s->ray.new_eye.y = (double)(s->ray.eye.y - plan->pos.y);
src/engine/inters.c:  s->ray.new_eye.z = (double)(s->ray.eye.z - plan->pos.z);
src/engine/inters.c:  rotation(&s->rotation, s->ray.vct, &plan->rot);
src/engine/inters.c:  rotation(&s->rotation, &s->ray.new_eye, &plan->rot);
src/engine/inters.c:  if (s->ray.vct->z == 0.0)
src/engine/inters.c:  s->hit.k1 = -1.0 * ((double)s->ray.new_eye.z / s->ray.vct->z);
src/engine/inters.c:  s->ray.new_eye.x = (double)(s->ray.eye.x - sphere->pos.x);
src/engine/inters.c:  s->ray.new_eye.y = (double)(s->ray.eye.y - sphere->pos.y);
src/engine/inters.c:  s->ray.new_eye.z = (double)(s->ray.eye.z - sphere->pos.z);
src/engine/inters.c:  rotation(&s->rotation, s->ray.vct, &sphere->rot);
src/engine/inters.c:  rotation(&s->rotation, &s->ray.new_eye, &sphere->rot);
src/engine/inters.c:  a = CARRE(s->ray.vct->x) + CARRE(s->ray.vct->y) +
src/engine/inters.c:    CARRE(s->ray.vct->z);
src/engine/inters.c:  b = 2 * (s->ray.new_eye.x * s->ray.vct->x + s->ray.new_eye.y
src/engine/inters.c:	   * s->ray.vct->y + s->ray.new_eye.z * s->ray.vct->z);
src/engine/inters.c:  c = CARRE(s->ray.new_eye.x) + CARRE(s->ray.new_eye.y)
src/engine/inters.c:    + CARRE(s->ray.new_eye.z)
src/engine/inters.c:    - CARRE(sphere->size);
src/engine/inters.c:  if ((delta = CARRE(b) - 4 * a * c) < 0.0001)
src/engine/inters.c:  s->hit.k1 = (- b + sqrt(delta)) / (2 * a);
src/engine/inters.c:  s->hit.k2 = (- b - sqrt(delta)) / (2 * a);
src/engine/inters.c:  angle = cone->angle * M_PI / 180.0;
src/engine/inters.c:  s->ray.new_eye.x = (double)(s->ray.eye.x - cone->pos.x);
src/engine/inters.c:  s->ray.new_eye.y = (double)(s->ray.eye.y - cone->pos.y);
src/engine/inters.c:  s->ray.new_eye.z = (double)(s->ray.eye.z - cone->pos.z);
src/engine/inters.c:  rotation(&s->rotation, s->ray.vct, &cone->rot);
src/engine/inters.c:  rotation(&s->rotation, &s->ray.new_eye, &cone->rot);
src/engine/inters.c:  a = CARRE(s->ray.vct->x) + CARRE(s->ray.vct->y)
src/engine/inters.c:    - CARRE(s->ray.vct->z) / CARRE(tan(angle));
src/engine/inters.c:  b = 2 * (s->ray.vct->y * s->ray.new_eye.y + s->ray.vct->x *
src/engine/inters.c:	   s->ray.new_eye.x
src/engine/inters.c:	   - (s->ray.vct->z * s->ray.new_eye.z) / CARRE(tan(angle)));
src/engine/inters.c:  c = CARRE(s->ray.new_eye.x) + CARRE(s->ray.new_eye.y)
src/engine/inters.c:    - CARRE(s->ray.new_eye.z) / CARRE(tan(angle));
src/engine/inters.c:  if ((delta = CARRE(b) - 4 * a * c) < 0)
src/engine/inters.c:  s->hit.k1 = (- b + sqrt(delta)) / (2 * a);
src/engine/inters.c:  s->hit.k2 = (- b - sqrt(delta)) / (2 * a);
src/engine/inters.c:  s->ray.new_eye.x = (double)(s->ray.eye.x - cylinder->pos.x);
src/engine/inters.c:  s->ray.new_eye.y = (double)(s->ray.eye.y - cylinder->pos.y);
src/engine/inters.c:  s->ray.new_eye.z = (double)(s->ray.eye.z - cylinder->pos.z);
src/engine/inters.c:  rotation(&s->rotation, s->ray.vct, &cylinder->rot);
src/engine/inters.c:  rotation(&s->rotation, &s->ray.new_eye, &cylinder->rot);
src/engine/inters.c:  a = CARRE(s->ray.vct->x) + CARRE(s->ray.vct->y);
src/engine/inters.c:  b = 2 * (s->ray.vct->x * s->ray.new_eye.x + s->ray.vct->y
src/engine/inters.c:	   * s->ray.new_eye.y);
src/engine/inters.c:  c = CARRE(s->ray.new_eye.x) + CARRE(s->ray.new_eye.y)
src/engine/inters.c:    - CARRE(cylinder->size);
src/engine/inters.c:  if ((delta = CARRE(b) - 4 * a * c) < 0)
src/engine/inters.c:  s->hit.k1 = (- b + sqrt(delta)) / (2 * a);
src/engine/inters.c:  s->hit.k2 = (- b - sqrt(delta)) / (2 * a);
src/engine/inter_hyper.c:  res->a = (CARRE(s->ray.vct->x) / CARRE(hyper->a)) +
src/engine/inter_hyper.c:    (CARRE(s->ray.vct->y) / CARRE(hyper->b)) -
src/engine/inter_hyper.c:    (CARRE(s->ray.vct->z) / CARRE(hyper->c));
src/engine/inter_hyper.c:  res->b = ((2 * s->ray.new_eye.x * s->ray.vct->x) / CARRE(hyper->a)) +
src/engine/inter_hyper.c:    ((2 * s->ray.new_eye.y * s->ray.vct->y) / CARRE(hyper->b)) -
src/engine/inter_hyper.c:    ((2 * s->ray.new_eye.z * s->ray.vct->z) / CARRE(hyper->b));
src/engine/inter_hyper.c:  res->c = (CARRE(s->ray.new_eye.x) / CARRE(hyper->a)) +
src/engine/inter_hyper.c:    (CARRE(s->ray.new_eye.y) / CARRE(hyper->b)) -
src/engine/inter_hyper.c:    (CARRE(s->ray.new_eye.z) / CARRE(hyper->c)) - 1;
src/engine/inter_hyper.c:  res->a = (CARRE(s->ray.vct->x) / CARRE(hyper->a)) +
src/engine/inter_hyper.c:    (CARRE(s->ray.vct->y) / CARRE(hyper->b)) -
src/engine/inter_hyper.c:    (CARRE(s->ray.vct->z) / CARRE(hyper->c));
src/engine/inter_hyper.c:  res->b = ((2 * s->ray.new_eye.x * s->ray.vct->x) / CARRE(hyper->a)) +
src/engine/inter_hyper.c:    ((2 * s->ray.new_eye.y * s->ray.vct->y) / CARRE(hyper->b)) -
src/engine/inter_hyper.c:    ((2 * s->ray.new_eye.z * s->ray.vct->z) / CARRE(hyper->b));
src/engine/inter_hyper.c:  res->c = (CARRE(s->ray.new_eye.x) / CARRE(hyper->a)) +
src/engine/inter_hyper.c:    (CARRE(s->ray.new_eye.y) / CARRE(hyper->b)) -
src/engine/inter_hyper.c:    (CARRE(s->ray.new_eye.z) / CARRE(hyper->c)) + 1;
src/engine/inter_hyper.c:  if (hyper->nappe == 1)
src/engine/inter_hyper.c:      s->ray.new_eye.x = s->ray.eye.x - hyper->pos.x;
src/engine/inter_hyper.c:      s->ray.new_eye.y = s->ray.eye.y - hyper->pos.y;
src/engine/inter_hyper.c:      s->ray.new_eye.z = s->ray.eye.z - hyper->pos.z;
src/engine/inter_hyper.c:      rotation(&s->rotation, s->ray.vct, &hyper->rot);
src/engine/inter_hyper.c:      rotation(&s->rotation, &s->ray.new_eye, &hyper->rot);
src/engine/inter_hyper.c:  else if (hyper->nappe == 2)
src/engine/inter_hyper.c:      s->ray.new_eye.x = s->ray.eye.x - hyper->pos.x;
src/engine/inter_hyper.c:      s->ray.new_eye.y = s->ray.eye.y - hyper->pos.y;
src/engine/inter_hyper.c:      s->ray.new_eye.z = s->ray.eye.z - hyper->pos.z;
src/engine/inter_hyper.c:      rotation(&s->rotation, s->ray.vct, &hyper->rot);
src/engine/inter_hyper.c:      rotation(&s->rotation, &s->ray.new_eye, &hyper->rot);
src/engine/shadow_inters.c:    return (-1);
src/engine/shadow_inters.c:  eye.x = (double)(s->shade.light_pos.x - sphere->pos.x);
src/engine/shadow_inters.c:  eye.y = (double)(s->shade.light_pos.y - sphere->pos.y);
src/engine/shadow_inters.c:  eye.z = (double)(s->shade.light_pos.z - sphere->pos.z);
src/engine/shadow_inters.c:  vct = set_pos(s->shade.vct.x, s->shade.vct.y, s->shade.vct.z);
src/engine/shadow_inters.c:  c = CARRE(eye.x) + CARRE(eye.y) + CARRE(eye.z) -
src/engine/shadow_inters.c:    CARRE(sphere->size);
src/engine/shadow_inters.c:  if ((delta = CARRE(b) - 4 * a * c) < 0.000001)
src/engine/shadow_inters.c:  k[0] = (- b + sqrt(delta)) / (2 * a);
src/engine/shadow_inters.c:  k[1] = (- b - sqrt(delta)) / (2 * a);
src/engine/shadow_inters.c:  angle = cone->angle * M_PI / 180.0;
src/engine/shadow_inters.c:  eye.x = (double)(s->shade.light_pos.x - cone->pos.x);
src/engine/shadow_inters.c:  eye.y = (double)(s->shade.light_pos.y - cone->pos.y);
src/engine/shadow_inters.c:  eye.z = (double)(s->shade.light_pos.z - cone->pos.z);
src/engine/shadow_inters.c:  vct = set_pos(s->shade.vct.x, s->shade.vct.y, s->shade.vct.z);
src/engine/shadow_inters.c:  rotation(&s->rotation, &vct, &cone->rot);
src/engine/shadow_inters.c:  rotation(&s->rotation, &eye, &cone->rot);
src/engine/shadow_inters.c:  a = CARRE(vct.x) + CARRE(vct.y) - CARRE(vct.z) / CARRE(tan(angle));
src/engine/shadow_inters.c:  b = 2 * (vct.y * eye.y + vct.x * eye.x - (vct.z * eye.z)
src/engine/shadow_inters.c:  c = CARRE(eye.x) + CARRE(eye.y) - CARRE(eye.z) / CARRE(tan(angle));
src/engine/shadow_inters.c:  if ((delta = CARRE(b) - 4 * a * c) < 0)
src/engine/shadow_inters.c:  k[0] = (- b + sqrt(delta)) / (2 * a);
src/engine/shadow_inters.c:  k[1] = (- b - sqrt(delta)) / (2 * a);
src/engine/shadow_inters.c:  eye.x = (double)(s->shade.light_pos.x - cylinder->pos.x);
src/engine/shadow_inters.c:  eye.y = (double)(s->shade.light_pos.y - cylinder->pos.y);
src/engine/shadow_inters.c:  eye.z = (double)(s->shade.light_pos.z - cylinder->pos.z);
src/engine/shadow_inters.c:  vct = set_pos(s->shade.vct.x, s->shade.vct.y, s->shade.vct.z);
src/engine/shadow_inters.c:  rotation(&s->rotation, &vct, &cylinder->rot);
src/engine/shadow_inters.c:  rotation(&s->rotation, &eye, &cylinder->rot);
src/engine/shadow_inters.c:  c = CARRE(eye.x) + CARRE(eye.y) - CARRE(cylinder->size);
src/engine/shadow_inters.c:  if ((delta = CARRE(b) - 4 * a * c) < 0)
src/engine/shadow_inters.c:  k[0] = (- b + sqrt(delta)) / (2 * a);
src/engine/shadow_inters.c:  k[1] = (- b - sqrt(delta)) / (2 * a);
src/engine/shadow_inters.c:  eye.x = (double)(s->shade.light_pos.x - plan->pos.x);
src/engine/shadow_inters.c:  eye.y = (double)(s->shade.light_pos.y - plan->pos.y);
src/engine/shadow_inters.c:  eye.z = (double)(s->shade.light_pos.z - plan->pos.z);
src/engine/shadow_inters.c:  vct = set_pos(s->shade.vct.x, s->shade.vct.y, s->shade.vct.z);
src/engine/shadow_inters.c:  rotation(&s->rotation, &vct, &plan->rot);
src/engine/shadow_inters.c:  rotation(&s->rotation, &eye, &plan->rot);
src/engine/shadow_inters.c:  k = -1.0 * ((double)eye.z / vct.z);
src/engine/inter_parab.c:  res->a = (CARRE(s->ray.vct->x) / CARRE(parab->a)) +
src/engine/inter_parab.c:    (CARRE(s->ray.vct->y) / CARRE(parab->b));
src/engine/inter_parab.c:  res->b = ((2 * s->ray.vct->x) / CARRE(parab->a)) +
src/engine/inter_parab.c:    ((2 * s->ray.vct->y) / CARRE(parab->b)) + s->ray.vct->z;
src/engine/inter_parab.c:  res->c = (CARRE(s->ray.new_eye.x) / CARRE(parab->a)) +
src/engine/inter_parab.c:    (CARRE(s->ray.new_eye.y) / CARRE(parab->b)) - s->ray.new_eye.z;
src/engine/inter_parab.c:  res->a = (CARRE(s->ray.vct->x) / CARRE(parab->a)) -
src/engine/inter_parab.c:    (CARRE(s->ray.vct->y) / CARRE(parab->b));
src/engine/inter_parab.c:  res->b = ((2 * s->ray.vct->x) / CARRE(parab->a)) -
src/engine/inter_parab.c:    ((2 * s->ray.vct->y) / CARRE(parab->b)) + s->ray.vct->z;
src/engine/inter_parab.c:  res->c = (CARRE(s->ray.new_eye.x) / CARRE(parab->a)) -
src/engine/inter_parab.c:    (CARRE(s->ray.new_eye.y) / CARRE(parab->b)) - s->ray.new_eye.z;
src/engine/inter_parab.c:  if (parab->form == 1)
src/engine/inter_parab.c:      s->ray.new_eye.x = s->ray.eye.x - parab->pos.x;
src/engine/inter_parab.c:      s->ray.new_eye.y = s->ray.eye.y - parab->pos.y;
src/engine/inter_parab.c:      s->ray.new_eye.z = s->ray.eye.z - parab->pos.z;
src/engine/inter_parab.c:      rotation(&s->rotation, s->ray.vct, &parab->rot);
src/engine/inter_parab.c:      rotation(&s->rotation, &s->ray.new_eye, &parab->rot);
src/engine/inter_parab.c:  else if (parab->form == 2)
src/engine/inter_parab.c:      s->ray.new_eye.x = s->ray.eye.x - parab->pos.x;
src/engine/inter_parab.c:      s->ray.new_eye.y = s->ray.eye.y - parab->pos.y;
src/engine/inter_parab.c:      s->ray.new_eye.z = s->ray.eye.z - parab->pos.z;
src/engine/inter_parab.c:      rotation(&s->rotation, s->ray.vct, &parab->rot);
src/engine/inter_parab.c:      rotation(&s->rotation, &s->ray.new_eye, &parab->rot);
src/engine/fresnel.c:  if (s->hit.k1 > 0.00001 && s->hit.k2 > 0.00001)
src/engine/fresnel.c:      s->hit.k1 = 0.0;
src/engine/fresnel.c:      s->hit.k2 = 0.0;
src/engine/fresnel.c:      s->ray.eye = eye;
src/engine/fresnel.c:      s->ray.vct = vct;
src/engine/fresnel.c:      s->ftabs.inters_ftab[s->obj_hit->next->type - 2](s, s->obj_hit->next);
src/engine/fresnel.c:      new_eye.x = eye.x + s->hit.k1 * vct->x;
src/engine/fresnel.c:      new_eye.y = eye.y + s->hit.k1 * vct->y;
src/engine/fresnel.c:      new_eye.z = eye.z + s->hit.k1 * vct->z;
src/engine/fresnel.c:      s->hit.norm.x = - s->hit.norm.x;
src/engine/fresnel.c:      s->hit.norm.y = - s->hit.norm.y;
src/engine/fresnel.c:      s->hit.norm.z = - s->hit.norm.z;
src/engine/fresnel.c:      f = get_refracted_vec(s, &s->hit.norm, s->hit.n2, 1);
src/engine/fresnel.c:  s->obj_hit = NULL;
src/engine/fresnel.c:  diffuse_color = s->final_color;
src/engine/fresnel.c:  reflection = s->hit.reflection;
src/engine/fresnel.c:  opacity = s->hit.opacity;
src/engine/fresnel.c:  inter = s->shade.inter;
src/engine/fresnel.c:  f = get_refracted_vec(s, &s->hit.norm, 1, s->hit.n2);
src/engine/fresnel.c:  s->rec++;
src/engine/fresnel.c:  refraction_color = init_refraction(s, &refraction_vct, s->shade.inter);
src/engine/fresnel.c:  s->obj_hit = NULL;
src/engine/fresnel.c:  color = compute_colors(diffuse_color, refraction_color, 1.0 - opacity);
src/engine/fresnel.c:  s->final_color = color;
src/engine/shadow_limited_objects.c:    return (-1);
src/engine/shadow_limited_objects.c:  if ((s->shade.shadow.simple_inter1.z <
src/engine/shadow_limited_objects.c:       - cylinder->height &&
src/engine/shadow_limited_objects.c:       s->shade.shadow.simple_inter2.z < - cylinder->height) ||
src/engine/shadow_limited_objects.c:      (s->shade.shadow.simple_inter1.z > cylinder->height &&
src/engine/shadow_limited_objects.c:       s->shade.shadow.simple_inter2.z > cylinder->height))
src/engine/shadow_limited_objects.c:  if (s->shade.shadow.simple_inter1.z < 0 ||
src/engine/shadow_limited_objects.c:      (s->shade.shadow.simple_inter1.z > cone->height &&
src/engine/shadow_limited_objects.c:       s->shade.shadow.simple_inter2.z > cone->height))
src/engine/load_sphere.c:  s->pos.x = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->pos.y = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->pos.z = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->rot.x = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->rot.y = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->rot.z = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->size = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->real = my_getnbr((char *)field);
src/engine/load_sphere.c:  if (s->real == 1)
src/engine/load_sphere.c:  s->ka = (double)my_getnbr((char *)field) / 100;
src/engine/load_sphere.c:  s->kd = (double)my_getnbr((char *)field) / 100;
src/engine/load_sphere.c:  s->ks = (double)my_getnbr((char *)field) / 100;
src/engine/load_sphere.c:  s->brightness = (double)my_getnbr((char *)field) / 100;
src/engine/load_sphere.c:  s->reflection = (double)my_getnbr((char *)field) / 100;
src/engine/load_sphere.c:  s->tex_type = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->opacity = my_getnbr((char *)field);
src/engine/load_sphere.c:  s->refraction = atof((char *)field);
src/engine/load_sphere.c:  s->color1.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_sphere.c:  s->color2.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_sphere.c:  if (s->tex_type == IMAGE)
src/engine/load_sphere.c:      s->tex_name = my_strdup((char *)field);
src/engine/load_sphere.c:      if ((s->texture = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_sphere.c:    return (-1);
src/engine/load_sphere.c:  if (rt->obj == NULL)
src/engine/load_sphere.c:      if ((rt->obj = create_obj_list()) == NULL)
src/engine/load_sphere.c:	return (-1);
src/engine/load_sphere.c:      if (add_obj_elem(rt->obj) == -1)
src/engine/load_sphere.c:	return (-1);
src/engine/load_sphere.c:  it = rt->obj;
src/engine/load_sphere.c:  while (it->next != NULL)
src/engine/load_sphere.c:    it = it->next;
src/engine/load_sphere.c:  it->type = 2;
src/engine/load_sphere.c:  if (load_sphere_datas(s, ini, scope) == -1)
src/engine/load_sphere.c:    return (-1);
src/engine/load_sphere.c:  it->datas = s;
src/engine/diffuse_light.c:  s->hit.nnorm.x = - s->hit.nnorm.x;
src/engine/diffuse_light.c:  s->hit.nnorm.y = - s->hit.nnorm.y;
src/engine/diffuse_light.c:  s->hit.nnorm.z = - s->hit.nnorm.z;
src/engine/diffuse_light.c:  s->hit.cos_theta = (s->hit.nnorm.x * s->shade.nvct.x * -1)
src/engine/diffuse_light.c:    + (s->hit.nnorm.y * s->shade.nvct.y * -1)
src/engine/diffuse_light.c:    + (s->hit.nnorm.z * s->shade.nvct.z * -1);
src/engine/diffuse_light.c:  if (s->hit.cos_theta < 0.0001)
src/engine/diffuse_light.c:    a = s->hit.cos_theta;
src/engine/diffuse_light.c:  len = sqrt(pow(s->shade.vct.x, 2) + pow(s->shade.vct.y, 2)
src/engine/diffuse_light.c:	     + pow(s->shade.vct.z, 2));
src/engine/diffuse_light.c:  s->shade.nvct.x = s->shade.vct.x / len;
src/engine/diffuse_light.c:  s->shade.nvct.y = s->shade.vct.y / len;
src/engine/diffuse_light.c:  s->shade.nvct.z = s->shade.vct.z / len;
src/engine/diffuse_light.c:  len = sqrt(pow(s->hit.norm.x, 2) + pow(s->hit.norm.y, 2)
src/engine/diffuse_light.c:	     + pow(s->hit.norm.z, 2));
src/engine/diffuse_light.c:  s->hit.nnorm.x = s->hit.norm.x / len;
src/engine/diffuse_light.c:  s->hit.nnorm.y = s->hit.norm.y / len;
src/engine/diffuse_light.c:  s->hit.nnorm.z = s->hit.norm.z / len;
src/engine/diffuse_light.c:  s->hit.cos_theta = (s->hit.nnorm.x * s->shade.nvct.x * -1)
src/engine/diffuse_light.c:    + (s->hit.nnorm.y * s->shade.nvct.y * -1)
src/engine/diffuse_light.c:    + (s->hit.nnorm.z * s->shade.nvct.z * -1);
src/engine/diffuse_light.c:  if ((it->type == 5 || s->hit.limited == 1) && s->hit.cos_theta < 0.00001)
src/engine/diffuse_light.c:  if (s->hit.cos_theta < 0.0001)
src/engine/diffuse_light.c:    a = s->hit.cos_theta;
src/engine/color_operations.c:  r = ((color1.full & 0xFF) * (1 - coef))
src/engine/color_operations.c:  g = (((color1.full >> 8) & 0xFF) * (1 - coef))
src/engine/color_operations.c:  b = (((color1.full >> 16) & 0xFF) * (1 - coef))
src/engine/color_operations.c:  r = (((color.full & 0xFF) * i) * (1 - brightness))
src/engine/color_operations.c:  g = ((((color.full >> 8) & 0xFF) * i) * (1 - brightness))
src/engine/color_operations.c:  b = ((((color.full >> 16) & 0xFF) * i) * (1 - brightness))
src/engine/load_cylinder.c:  s->pos.x = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->pos.y = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->pos.z = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->rot.x = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->rot.y = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->rot.z = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->height = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->size = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->real = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->refraction = atof((char *)field);
src/engine/load_cylinder.c:  if (s->real == 1)
src/engine/load_cylinder.c:  s->ka = (double)my_getnbr((char *)field) / 100;
src/engine/load_cylinder.c:  s->kd = (double)my_getnbr((char *)field) / 100;
src/engine/load_cylinder.c:  s->ks = (double)my_getnbr((char *)field) / 100;
src/engine/load_cylinder.c:  s->brightness = (double)my_getnbr((char *)field) / 100;
src/engine/load_cylinder.c:  s->reflection = (double)my_getnbr((char *)field) / 100;
src/engine/load_cylinder.c:  s->tex_type = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->opacity = my_getnbr((char *)field);
src/engine/load_cylinder.c:  s->color1.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_cylinder.c:  s->color2.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_cylinder.c:  if (s->tex_type == IMAGE)
src/engine/load_cylinder.c:      s->tex1_name = my_strdup((char *)field);
src/engine/load_cylinder.c:      if ((s->texture2 = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_cylinder.c:      s->tex2_name = my_strdup((char *)field);
src/engine/load_cylinder.c:      if ((s->texture1 = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_cylinder.c:    return (-1);
src/engine/load_cylinder.c:  if (rt->obj == NULL)
src/engine/load_cylinder.c:      if ((rt->obj = create_obj_list()) == NULL)
src/engine/load_cylinder.c:	return (-1);
src/engine/load_cylinder.c:      if (add_obj_elem(rt->obj) == -1)
src/engine/load_cylinder.c:	return (-1);
src/engine/load_cylinder.c:  it = rt->obj;
src/engine/load_cylinder.c:  while (it->next != NULL)
src/engine/load_cylinder.c:    it = it->next;
src/engine/load_cylinder.c:  it->type = 3;
src/engine/load_cylinder.c:  if (load_cylinder_datas(s, ini, scope) == -1)
src/engine/load_cylinder.c:    return (-1);
src/engine/load_cylinder.c:  it->datas = s;
src/engine/shadow_simple_inters.c:    return (-1);
src/engine/shadow_simple_inters.c:  if (k[0] < s->hit.k1 && k[1] > 0.000001)
src/engine/shadow_simple_inters.c:  s->shade.shadow.simple_inter1.x = eye->x + k[0] * vct->x;
src/engine/shadow_simple_inters.c:  s->shade.shadow.simple_inter1.y = eye->y + k[0] * vct->y;
src/engine/shadow_simple_inters.c:  s->shade.shadow.simple_inter1.z = eye->z + k[0] * vct->z;
src/engine/shadow_simple_inters.c:  s->shade.shadow.simple_inter2.x = eye->x + k[1] * vct->x;
src/engine/shadow_simple_inters.c:  s->shade.shadow.simple_inter2.y = eye->y + k[1] * vct->y;
src/engine/shadow_simple_inters.c:  s->shade.shadow.simple_inter2.z = eye->z + k[1] * vct->z;
src/engine/antialiasing.c:  while (i < s->opt.aa)
src/engine/antialiasing.c:  r = r / s->opt.aa;
src/engine/antialiasing.c:  g = g / s->opt.aa;
src/engine/antialiasing.c:  b = b / s->opt.aa;
src/engine/antialiasing.c:  i = -1;
src/engine/antialiasing.c:  x = sqrt(s->opt.aa);
src/engine/antialiasing.c:      j = -1;
src/engine/antialiasing.c:	  vct->x = ((double)s->width / 2.0)
src/engine/antialiasing.c:	    - ((double)pos->x + (1.0 / (double)x) * j);
src/engine/antialiasing.c:	  vct->y = ((double)s->height / 2.0)
src/engine/antialiasing.c:	    - ((double)pos->y + (1.0 / (double)x) * i);
src/engine/antialiasing.c:	  vct->z = 1000;
src/engine/antialiasing.c:	  rotation(&s->rotation, vct, &s->eye.rot);
src/engine/antialiasing.c:	  s->rec = 0;
src/engine/antialiasing.c:	  color[k++] = display_objects(s, vct, s->eye.pos);
src/engine/exposure.c:  exposure = -1.0;
src/engine/exposure.c:  i = 1.0 - expf(i * exposure);
src/engine/inter_box_sides.c:  vec[0].y = box->size.y;
src/engine/inter_box_sides.c:  rotation(&s->rotation, &vec[0], &box->rot);
src/engine/inter_box_sides.c:  vec[1].y = - box->size.y;
src/engine/inter_box_sides.c:  rotation(&s->rotation, &vec[1], &box->rot);
src/engine/inter_box_sides.c:  vec[2].x = box->size.x;
src/engine/inter_box_sides.c:  rotation(&s->rotation, &vec[2], &box->rot);
src/engine/inter_box_sides.c:  vec[3].x = - box->size.x;
src/engine/inter_box_sides.c:  rotation(&s->rotation, &vec[3], &box->rot);
src/engine/inter_box_sides.c:  vec[4].z = box->size.z;
src/engine/inter_box_sides.c:  rotation(&s->rotation, &vec[4], &box->rot);
src/engine/inter_box_sides.c:  vec[5].z = - box->size.z;
src/engine/inter_box_sides.c:  rotation(&s->rotation, &vec[5], &box->rot);
src/engine/inter_box_sides.c:  rot[0].x = box->rot.x + 90;
src/engine/inter_box_sides.c:  rot[0].y = box->rot.y;
src/engine/inter_box_sides.c:  rot[0].z = box->rot.z;
src/engine/inter_box_sides.c:  rot[1].x = box->rot.x + 90;
src/engine/inter_box_sides.c:  rot[1].y = box->rot.y;
src/engine/inter_box_sides.c:  rot[1].z = box->rot.z;
src/engine/inter_box_sides.c:  rot[2].x = box->rot.x;
src/engine/inter_box_sides.c:  rot[2].y = box->rot.y + 90;
src/engine/inter_box_sides.c:  rot[2].z = box->rot.z;
src/engine/inter_box_sides.c:  rot[3].x = box->rot.x;
src/engine/inter_box_sides.c:  rot[3].y = box->rot.y + 90;
src/engine/inter_box_sides.c:  rot[3].z = box->rot.z;
src/engine/inter_box_sides.c:  rot[4].x = box->rot.x;
src/engine/inter_box_sides.c:  rot[4].y = box->rot.y;
src/engine/inter_box_sides.c:  rot[4].z = box->rot.z;
src/engine/inter_box_sides.c:  rot[5].x = box->rot.x;
src/engine/inter_box_sides.c:  rot[5].y = box->rot.y;
src/engine/inter_box_sides.c:  rot[5].z = box->rot.z;
src/engine/inter_box_sides.c:      plan.pos.x = box->pos.x + vec[i].x;
src/engine/inter_box_sides.c:      plan.pos.y = box->pos.y + vec[i].y;
src/engine/inter_box_sides.c:      plan.pos.z = box->pos.z + vec[i].z;
src/engine/load_plan.c:  s->pos.x = my_getnbr((char *)field);
src/engine/load_plan.c:  s->pos.y = my_getnbr((char *)field);
src/engine/load_plan.c:  s->pos.z = my_getnbr((char *)field);
src/engine/load_plan.c:  s->rot.x = my_getnbr((char *)field);
src/engine/load_plan.c:  s->rot.y = my_getnbr((char *)field);
src/engine/load_plan.c:  s->rot.z = my_getnbr((char *)field);
src/engine/load_plan.c:  s->reflection = (double)my_getnbr((char *)field) / 100;
src/engine/load_plan.c:  s->height = my_getnbr((char *)field) / 2;
src/engine/load_plan.c:  s->width = my_getnbr((char *)field) / 2;
src/engine/load_plan.c:  s->ka = (double)my_getnbr((char *)field) / 100;
src/engine/load_plan.c:  s->kd = (double)my_getnbr((char *)field) / 100;
src/engine/load_plan.c:  s->ks = (double)my_getnbr((char *)field) / 100;
src/engine/load_plan.c:  s->brightness = (double)my_getnbr((char *)field) / 100;
src/engine/load_plan.c:  s->opacity = (double)my_getnbr((char *)field) / 100;
src/engine/load_plan.c:  s->refraction = atof((char *)field);
src/engine/load_plan.c:  s->tex_type = my_getnbr((char *)field);
src/engine/load_plan.c:  s->color1.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_plan.c:  s->color2.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_plan.c:  s->case_size = my_getnbr((char *)field);
src/engine/load_plan.c:  if (s->tex_type == IMAGE)
src/engine/load_plan.c:      s->tex_name = my_strdup((char *)field);
src/engine/load_plan.c:      if ((s->texture = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_plan.c:    return (-1);
src/engine/load_plan.c:  if (rt->obj == NULL)
src/engine/load_plan.c:      if ((rt->obj = create_obj_list()) == NULL)
src/engine/load_plan.c:	return (-1);
src/engine/load_plan.c:      if (add_obj_elem(rt->obj) == -1)
src/engine/load_plan.c:	return (-1);
src/engine/load_plan.c:  it = rt->obj;
src/engine/load_plan.c:  while (it->next != NULL)
src/engine/load_plan.c:    it = it->next;
src/engine/load_plan.c:  it->type = 5;
src/engine/load_plan.c:  if (load_plan_datas(s, ini, scope) == -1)
src/engine/load_plan.c:    return (-1);
src/engine/load_plan.c:  it->datas = s;
src/engine/limited_objects.c:  pos.z = cylinder->height;
src/engine/limited_objects.c:  end_rotation(&s->rotation, &pos, &cylinder->rot);
src/engine/limited_objects.c:  plan.pos.x = cylinder->pos.x + pos.x;
src/engine/limited_objects.c:  plan.pos.y = cylinder->pos.y + pos.y;
src/engine/limited_objects.c:  plan.pos.z = cylinder->pos.z + pos.y;
src/engine/limited_objects.c:  plan.rot.x = cylinder->rot.x;
src/engine/limited_objects.c:  plan.rot.y = cylinder->rot.y;
src/engine/limited_objects.c:  plan.rot.z = cylinder->rot.z;
src/engine/limited_objects.c:  get_simple_inter(s, s->ray.vct, &s->ray.new_eye);
src/engine/limited_objects.c:  end_rotation(&s->rotation, s->ray.vct, &plan.rot);
src/engine/limited_objects.c:  s->hit.limited = 1;
src/engine/limited_objects.c:  pos.z = - cylinder->height;
src/engine/limited_objects.c:  end_rotation(&s->rotation, &pos, &cylinder->rot);
src/engine/limited_objects.c:  plan.pos.x = cylinder->pos.x + pos.x;
src/engine/limited_objects.c:  plan.pos.y = cylinder->pos.y + pos.y;
src/engine/limited_objects.c:  plan.pos.z = cylinder->pos.z + pos.y;
src/engine/limited_objects.c:  plan.rot.x = cylinder->rot.x;
src/engine/limited_objects.c:  plan.rot.y = cylinder->rot.y;
src/engine/limited_objects.c:  plan.rot.z = cylinder->rot.z;
src/engine/limited_objects.c:  get_simple_inter(s, s->ray.vct, &s->ray.new_eye);
src/engine/limited_objects.c:  end_rotation(&s->rotation, s->ray.vct, &plan.rot);
src/engine/limited_objects.c:  s->hit.limited = 1;
src/engine/limited_objects.c:  if ((s->hit.simple_inter1.z < - cylinder->height &&
src/engine/limited_objects.c:       s->hit.simple_inter2.z < - cylinder->height) ||
src/engine/limited_objects.c:      (s->hit.simple_inter1.z > cylinder->height &&
src/engine/limited_objects.c:       s->hit.simple_inter2.z > cylinder->height))
src/engine/limited_objects.c:    return (-1);
src/engine/limited_objects.c:  else if (s->hit.simple_inter1.z < - cylinder->height)
src/engine/limited_objects.c:  else if (s->hit.simple_inter1.z > cylinder->height)
src/engine/limited_objects.c:  pos.z = - cone->height;
src/engine/limited_objects.c:  end_rotation(&s->rotation, &pos, &cone->rot);
src/engine/limited_objects.c:  plan.pos.x = cone->pos.x + pos.x;
src/engine/limited_objects.c:  plan.pos.y = cone->pos.y + pos.y;
src/engine/limited_objects.c:  plan.pos.z = cone->pos.z + pos.y;
src/engine/limited_objects.c:  plan.rot.x = cone->rot.x;
src/engine/limited_objects.c:  plan.rot.y = cone->rot.y;
src/engine/limited_objects.c:  plan.rot.z = cone->rot.z;
src/engine/limited_objects.c:  get_simple_inter(s, s->ray.vct, &s->ray.new_eye);
src/engine/limited_objects.c:  end_rotation(&s->rotation, s->ray.vct, &plan.rot);
src/engine/limited_objects.c:  s->hit.limited = 1;
src/engine/limited_objects.c:  if (s->hit.simple_inter1.z < 0)
src/engine/limited_objects.c:    return (-1);
src/engine/limited_objects.c:  else if (s->hit.simple_inter1.z > cone->height)
src/engine/limited_objects.c:      if (s->hit.simple_inter2.z > 0.0 &&
src/engine/limited_objects.c:	  s->hit.simple_inter2.z < cone->height)
src/engine/limited_objects.c:	return (-1);
src/engine/create_obj_list.c:  root->next = NULL;
src/engine/create_obj_list.c:  root->prev = NULL;
src/engine/create_obj_list.c:  while (it->next != NULL)
src/engine/create_obj_list.c:    it = it->next;
src/engine/create_obj_list.c:  it->next = new;
src/engine/create_obj_list.c:  new->prev = it;
src/engine/create_obj_list.c:  new->next = NULL;
src/engine/create_obj_list.c:  while (it->next != NULL)
src/engine/create_obj_list.c:    it = it->next;
src/engine/create_obj_list.c:  it->next = new;
src/engine/create_obj_list.c:  new->prev = it;
src/engine/create_obj_list.c:  new->next = NULL;
src/engine/matrices.c:      rot->cos[i] = cos(RAD((double)i));
src/engine/matrices.c:      rot->sin[i] = sin(RAD((double)i));
src/engine/matrices.c:	  rot->rotx[j][i] = 0;
src/engine/matrices.c:	  rot->roty[j][i] = 0;
src/engine/matrices.c:	  rot->rotz[j][i] = 0;
src/engine/matrices.c:  rot->rotx[1][1] = 1;
src/engine/matrices.c:  rot->roty[2][2] = 1;
src/engine/matrices.c:  rot->rotz[0][0] = 1;
src/engine/matrices.c:  rot->rotx[0][0] = rot->cos[teta];
src/engine/matrices.c:  rot->rotx[0][2] = rot->sin[teta];
src/engine/matrices.c:  rot->rotx[2][0] = -rot->sin[teta];
src/engine/matrices.c:  rot->rotx[2][2] = rot->cos[teta];
src/engine/matrices.c:  rot->roty[0][0] = rot->cos[teta];
src/engine/matrices.c:  rot->roty[0][1] = -rot->sin[teta];
src/engine/matrices.c:  rot->roty[1][0] = rot->sin[teta];
src/engine/matrices.c:  rot->roty[1][1] = rot->cos[teta];
src/engine/matrices.c:  rot->rotz[1][1] = rot->cos[teta];
src/engine/matrices.c:  rot->rotz[1][2] = -rot->sin[teta];
src/engine/matrices.c:  rot->rotz[2][1] = rot->sin[teta];
src/engine/matrices.c:  rot->rotz[2][2] = rot->cos[teta];
src/engine/checkerboards.c:  if (sin(M_PI / 1000) * sin((M_PI / 1000) * s->hit.simple_inter1.x) >= 0)
src/engine/checkerboards.c:    s->final_color = s->hit.color1;
src/engine/checkerboards.c:    s->final_color = s->hit.color2;
src/engine/checkerboards.c:  jump = ((int)(5000 + s->hit.simple_inter1.x / 1000)
src/engine/checkerboards.c:	  + (int)(5000 + s->hit.simple_inter1.y / 1000)) % 2;
src/engine/checkerboards.c:    s->final_color = s->hit.color1;
src/engine/checkerboards.c:    s->final_color = s->hit.color2;
src/engine/checkerboards.c:  jump = ((int)(5000 + (s->hit.texels.x * 20000) / 1000)
src/engine/checkerboards.c:	  + (int)(5000 + (s->hit.texels.y * 20000) / 1000)) % 2;
src/engine/checkerboards.c:    s->final_color = s->hit.color1;
src/engine/checkerboards.c:    s->final_color = s->hit.color2;
src/engine/checkerboards.c:  jump = ((int)(5000 + s->hit.simple_inter1.x / 1000)
src/engine/checkerboards.c:	  + (int)(5000 + s->hit.simple_inter1.y / 1000)
src/engine/checkerboards.c:	  + (int)(5000 + s->hit.simple_inter1.z / 1000)) % 2;
src/engine/checkerboards.c:    s->final_color = s->hit.color1;
src/engine/checkerboards.c:    s->final_color = s->hit.color2;
src/engine/display.c:  s->ftabs.inters_ftab[0] = &display_sphere;
src/engine/display.c:  s->ftabs.inters_ftab[1] = &display_cylinder;
src/engine/display.c:  s->ftabs.inters_ftab[2] = &display_cone;
src/engine/display.c:  s->ftabs.inters_ftab[3] = &display_plan;
src/engine/display.c:  s->ftabs.inters_ftab[4] = &display_box;
src/engine/display.c:  it = s->obj;
src/engine/display.c:      s->hit.k1 = 0.0;
src/engine/display.c:      s->hit.k2 = 0.0;
src/engine/display.c:      if (it->type > 1)
src/engine/display.c:	s->ftabs.inters_ftab[it->type - 2](s, it);
src/engine/display.c:      it = it->next;
src/engine/display.c:  if (s->rec == 2)
src/engine/display.c:      s->rec = 0;
src/engine/display.c:      return (s->final_color);
src/engine/display.c:  s->ray.eye = eye;
src/engine/display.c:  s->ray.vct = vct;
src/engine/display.c:  order_hit_list(s->obj_hit);
src/engine/display.c:  if (s->obj_hit != NULL && s->obj_hit->next != NULL)
src/engine/display.c:      set_hit_values(s, s->obj_hit->next);
src/engine/display.c:      shade(s, s->ray.vct, s->ray.eye);
src/engine/display.c:      color = s->final_color;
src/engine/display.c:      clear_list(s->obj_hit);
src/engine/display.c:      s->obj_hit = NULL;
src/engine/display.c:  color = s->final_color;
src/engine/display.c:    data->ld.loading->clipable.clip_width = 1;
src/engine/display.c:  else if (y % (int)rt->coef_load == 0)
src/engine/display.c:      data->ld.curr_line += LOADING_COEF;
src/engine/display.c:      data->ld.loading->clipable.clip_width = data->ld.curr_line;
src/engine/display.c:      data->ld.nb_coef++;
src/engine/display.c:  if (y > rt->coef_load * rt->nb_coef)
src/engine/display.c:    rt->nb_coef++;
src/engine/display.c:  bunny_blit(&data->win->buffer,
src/engine/display.c:	     &data->ld.loading->clipable, &data->ld.pos);
src/engine/display.c:  s->nb_coef = 1;
src/engine/display.c:  data->ld.nb_coef = 1;
src/engine/display.c:  data->ld.curr_line = 0;
src/engine/display.c:  if ((s->shade.itab = bunny_malloc(sizeof(double) * s->opt.nb_rays_ss))
src/engine/display.c:    return (-1);
src/engine/display.c:  if (s->r_pos.y < 500)
src/engine/display.c:      s->r_pos.x = 0;
src/engine/display.c:      while (s->r_pos.x < 640)
src/engine/display.c:	  s->rec = 0;
src/engine/display.c:	  final_color = antialiasing(s, &s->r_pos, &vct, s->pixel_color);
src/engine/display.c:	  tekpixel(s->img, &s->r_pos, &final_color);
src/engine/display.c:	  s->r_pos.x++;
src/engine/display.c:      s->r_pos.y++;
src/engine/display.c:  if (s->r_pos.y == s->height)
src/engine/display.c:      data->itfc.rendering = false;
src/engine/display.c:      data->itfc.rendered = true;
src/engine/display.c:      data->ld.loading->clipable.clip_width = data->ld.save_width;
src/engine/display.c:  bunny_free(s->shade.itab);
src/engine/init_shade.c:  if (s->opt.ss == 1)
src/engine/init_shade.c:      rd = rand() % s->opt.ray_ss;
src/engine/init_shade.c:      s->shade.x_diff = rd - (s->opt.ray_ss / 2);
src/engine/init_shade.c:      rd = rand() % s->opt.ray_ss;
src/engine/init_shade.c:      s->shade.y_diff = rd - (s->opt.ray_ss / 2);
src/engine/init_shade.c:      rd = rand() % s->opt.ray_ss;
src/engine/init_shade.c:      s->shade.z_diff = rd - (s->opt.ray_ss / 2);
src/engine/init_shade.c:      s->shade.x_diff = 0;
src/engine/init_shade.c:      s->shade.y_diff = 0;
src/engine/init_shade.c:      s->shade.z_diff = 0;
src/engine/init_shade.c:  s->shade.inter.x = eye.x + s->hit.k1 * vct->x;
src/engine/init_shade.c:  s->shade.inter.y = eye.y + s->hit.k1 * vct->y;
src/engine/init_shade.c:  s->shade.inter.z = eye.z + s->hit.k1 * vct->z;
src/engine/init_shade.c:  s->shade.light_pos.x = light->pos.x + s->shade.x_diff;
src/engine/init_shade.c:  s->shade.light_pos.y = light->pos.y + s->shade.y_diff;
src/engine/init_shade.c:  s->shade.light_pos.z = light->pos.z + s->shade.z_diff;
src/engine/init_shade.c:  s->shade.vct.x = s->shade.inter.x - (double)s->shade.light_pos.x;
src/engine/init_shade.c:  s->shade.vct.y = s->shade.inter.y - (double)s->shade.light_pos.y;
src/engine/init_shade.c:  s->shade.vct.z = s->shade.inter.z - (double)s->shade.light_pos.z;
src/engine/load_light.c:  s->pos.x = my_getnbr((char *)field);
src/engine/load_light.c:  s->pos.y = my_getnbr((char *)field);
src/engine/load_light.c:  s->pos.z = my_getnbr((char *)field);
src/engine/load_light.c:  s->intensity = (double)my_getnbr((char *)field) / 100.0;
src/engine/load_light.c:  s->color.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_light.c:    return (-1);
src/engine/load_light.c:  if (rt->obj == NULL)
src/engine/load_light.c:      if ((rt->obj = create_obj_list()) == NULL)
src/engine/load_light.c:	return (-1);
src/engine/load_light.c:      if (add_obj_elem(rt->obj) == -1)
src/engine/load_light.c:	return (-1);
src/engine/load_light.c:  it = rt->obj;
src/engine/load_light.c:  while (it->next != NULL)
src/engine/load_light.c:    it = it->next;
src/engine/load_light.c:  it->type = 1;
src/engine/load_light.c:  if (load_light_datas(s, ini, scope) == -1)
src/engine/load_light.c:    return (-1);
src/engine/load_light.c:  it->datas = s;
src/engine/get_simple_coords.c:  if (s->hit.k1 < 0.000001 && s->hit.k2 < 0.000001)
src/engine/get_simple_coords.c:    return (-1);
src/engine/get_simple_coords.c:  if (s->hit.k2 < s->hit.k1 && s->hit.k2 > 0.000001)
src/engine/get_simple_coords.c:      tmp = s->hit.k2;
src/engine/get_simple_coords.c:      s->hit.k2 = s->hit.k1;
src/engine/get_simple_coords.c:      s->hit.k1 = tmp;
src/engine/get_simple_coords.c:  if (s->hit.k1 < 0.000001 && s->hit.k2 > 0.000001)
src/engine/get_simple_coords.c:      tmp = s->hit.k2;
src/engine/get_simple_coords.c:      s->hit.k2 = s->hit.k1;
src/engine/get_simple_coords.c:      s->hit.k1 = tmp;
src/engine/get_simple_coords.c:  s->hit.simple_inter1.x = eye->x + s->hit.k1 * vct->x;
src/engine/get_simple_coords.c:  s->hit.simple_inter1.y = eye->y + s->hit.k1 * vct->y;
src/engine/get_simple_coords.c:  s->hit.simple_inter1.z = eye->z + s->hit.k1 * vct->z;
src/engine/get_simple_coords.c:  s->hit.simple_inter2.x = eye->x + s->hit.k2 * vct->x;
src/engine/get_simple_coords.c:  s->hit.simple_inter2.y = eye->y + s->hit.k2 * vct->y;
src/engine/get_simple_coords.c:  s->hit.simple_inter2.z = eye->z + s->hit.k2 * vct->z;
src/engine/rotations.c:  save_x = vct->x;
src/engine/rotations.c:  save_y = vct->y;
src/engine/rotations.c:  vct->x = r->rotx[0][0] * save_x
src/engine/rotations.c:    + r->rotx[0][1] * save_y + r->rotx[0][2] * vct->z;
src/engine/rotations.c:  vct->y = r->rotx[1][0] * save_x
src/engine/rotations.c:    + r->rotx[1][1] * save_y + r->rotx[1][2] * vct->z;
src/engine/rotations.c:  vct->z = r->rotx[2][0] * save_x
src/engine/rotations.c:    + r->rotx[2][1] * save_y + r->rotx[2][2] * vct->z;
src/engine/rotations.c:  save_x = vct->x;
src/engine/rotations.c:  save_y = vct->y;
src/engine/rotations.c:  vct->x = r->roty[0][0] * save_x
src/engine/rotations.c:    + r->roty[0][1] * save_y + r->roty[0][2] * vct->z;
src/engine/rotations.c:  vct->y = r->roty[1][0] * save_x
src/engine/rotations.c:    + r->roty[1][1] * save_y + r->roty[1][2] * vct->z;
src/engine/rotations.c:  vct->z = r->roty[2][0] * save_x
src/engine/rotations.c:    + r->roty[2][1] * save_y + r->roty[2][2] * vct->z;
src/engine/rotations.c:  save_x = vct->x;
src/engine/rotations.c:  save_y = vct->y;
src/engine/rotations.c:  vct->x = r->rotz[0][0] * save_x + r->rotz[0][1] * save_y
src/engine/rotations.c:    + r->rotz[0][2] * vct->z;
src/engine/rotations.c:  vct->y = r->rotz[1][0] * save_x + r->rotz[1][1] * save_y
src/engine/rotations.c:    + r->rotz[1][2] * vct->z;
src/engine/rotations.c:  vct->z = r->rotz[2][0] * save_x + r->rotz[2][1] * save_y
src/engine/rotations.c:    + r->rotz[2][2] * vct->z;
src/engine/rotations.c:  vct = rotate_x(r, vct, (360 - rot->x) % 360);
src/engine/rotations.c:  vct = rotate_y(r, vct, (360 - rot->y) % 360);
src/engine/rotations.c:  vct = rotate_z(r, vct, (360 - rot->z) % 360);
src/engine/rotations.c:  vct = rotate_z(r, vct, (360 - (-rot->z)) % 360);
src/engine/rotations.c:  vct = rotate_y(r, vct, (360 - (-rot->y)) % 360);
src/engine/rotations.c:  vct = rotate_x(r, vct, (360 - (-rot->x)) % 360);
src/engine/translation.c:  pos->x += vec->x;
src/engine/translation.c:  pos->y += vec->y;
src/engine/translation.c:  pos->z += vec->z;
src/engine/translation.c:  pos->x += vec->x;
src/engine/translation.c:  pos->y += vec->y;
src/engine/translation.c:  pos->z += vec->z;
src/engine/load_box.c:  s->pos.x = my_getnbr((char *)field);
src/engine/load_box.c:  s->pos.y = my_getnbr((char *)field);
src/engine/load_box.c:  s->pos.z = my_getnbr((char *)field);
src/engine/load_box.c:  s->rot.x = my_getnbr((char *)field);
src/engine/load_box.c:  s->rot.y = my_getnbr((char *)field);
src/engine/load_box.c:  s->rot.z = my_getnbr((char *)field);
src/engine/load_box.c:  s->reflection = (double)my_getnbr((char *)field) / 100;
src/engine/load_box.c:  s->size.x = my_getnbr((char *)field) / 2;
src/engine/load_box.c:  s->size.y = my_getnbr((char *)field) / 2;
src/engine/load_box.c:  s->size.z = my_getnbr((char *)field) / 2;
src/engine/load_box.c:  s->ka = (double)my_getnbr((char *)field) / 100;
src/engine/load_box.c:  s->kd = (double)my_getnbr((char *)field) / 100;
src/engine/load_box.c:  s->ks = (double)my_getnbr((char *)field) / 100;
src/engine/load_box.c:  s->brightness = (double)my_getnbr((char *)field) / 100;
src/engine/load_box.c:  s->opacity = (double)my_getnbr((char *)field) / 100;
src/engine/load_box.c:  s->refraction = atof((char *)field);
src/engine/load_box.c:  s->tex_type = my_getnbr((char *)field);
src/engine/load_box.c:  s->color1.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_box.c:  s->color2.full = my_getcolor((char *)field, "0123456789ABCDEF");
src/engine/load_box.c:  if (s->tex_type == IMAGE)
src/engine/load_box.c:      s->tex_name = my_strdup((char *)field);
src/engine/load_box.c:      if ((s->texture = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_box.c:    return (-1);
src/engine/load_box.c:  if (rt->obj == NULL)
src/engine/load_box.c:      if ((rt->obj = create_obj_list()) == NULL)
src/engine/load_box.c:	return (-1);
src/engine/load_box.c:      if (add_obj_elem(rt->obj) == -1)
src/engine/load_box.c:	return (-1);
src/engine/load_box.c:  it = rt->obj;
src/engine/load_box.c:  while (it->next != NULL)
src/engine/load_box.c:    it = it->next;
src/engine/load_box.c:  it->type = 6;
src/engine/load_box.c:  if (load_box_datas(s, ini, scope) == -1)
src/engine/load_box.c:    return (-1);
src/engine/load_box.c:  it->datas = s;
src/engine/get_texels.c:  s->hit.texels.x = (plan->simple_inter1.x + (plan->width / 2))
src/engine/get_texels.c:    / plan->width;
src/engine/get_texels.c:  s->hit.texels.y = (plan->simple_inter1.y + (plan->height / 2))
src/engine/get_texels.c:    / plan->height;
src/engine/get_texels.c:  r = sqrt((sphere->simple_inter1.x * sphere->simple_inter1.x)
src/engine/get_texels.c:	   + (sphere->simple_inter1.y * sphere->simple_inter1.y)
src/engine/get_texels.c:	   + (sphere->simple_inter1.z * sphere->simple_inter1.z));
src/engine/get_texels.c:  col = acos(sphere->simple_inter1.y / r);
src/engine/get_texels.c:  if (sphere->simple_inter1.x >= 0)
src/engine/get_texels.c:    theta = acos(sphere->simple_inter1.z
src/engine/get_texels.c:		 / sqrt(pow(sphere->simple_inter1.z, 2)
src/engine/get_texels.c:			+ pow(sphere->simple_inter1.x, 2)));
src/engine/get_texels.c:      - acos(sphere->simple_inter1.z
src/engine/get_texels.c:	     / sqrt(pow(sphere->simple_inter1.z, 2)
src/engine/get_texels.c:		    + pow(sphere->simple_inter1.x, 2)));
src/engine/get_texels.c:  s->hit.texels.x = theta / (2 * M_PI);
src/engine/get_texels.c:  s->hit.texels.y = col / M_PI;
src/engine/get_texels.c:  s->hit.texels.x = ((cylinder->simple_inter1.x / cylinder->size) + 1.0)
src/engine/get_texels.c:  s->hit.texels.y = ((cylinder->simple_inter1.y / cylinder->size) + 1.0)
src/engine/get_texels.c:  if (s->hit.simple_inter1.x >= 0)
src/engine/get_texels.c:    theta = acos(cylinder->simple_inter1.y
src/engine/get_texels.c:		 / sqrt(pow(cylinder->simple_inter1.y, 2)
src/engine/get_texels.c:			+ pow(cylinder->simple_inter1.x, 2)));
src/engine/get_texels.c:    theta = (2 * M_PI) - acos(cylinder->simple_inter1.y
src/engine/get_texels.c:			      / sqrt(pow(cylinder->simple_inter1.y, 2)
src/engine/get_texels.c:				     + pow(cylinder->simple_inter1.x, 2)));
src/engine/get_texels.c:  y = (cylinder->simple_inter1.z + cylinder->height) / (2 * cylinder->height);
src/engine/get_texels.c:  s->hit.texels.x = theta / (2 * M_PI);
src/engine/get_texels.c:  s->hit.texels.y = y;
src/engine/noise_textures.c:  vec[0] = s->hit.simple_inter1.x * 0.0005;
src/engine/noise_textures.c:  vec[1] = s->hit.simple_inter1.y * 0.0005;
src/engine/noise_textures.c:  vec[2] = s->hit.simple_inter1.z * 0.0005;
src/engine/noise_textures.c:    noise *= -1;
src/engine/noise_textures.c:  s->final_color = compute_colors(s->hit.color1, s->hit.color2, noise);
src/engine/noise_textures.c:  vec[0] = s->hit.simple_inter1.x * 0.0005;
src/engine/noise_textures.c:  vec[1] = s->hit.simple_inter1.y * 0.0005;
src/engine/noise_textures.c:  vec[2] = s->hit.simple_inter1.z * 0.0005;
src/engine/noise_textures.c:  noise = 0.5 * sin((s->hit.simple_inter1.x + s->hit.simple_inter1.y)
src/engine/noise_textures.c:    noise *= -1;
src/engine/noise_textures.c:  s->final_color = compute_colors(s->hit.color1, s->hit.color2, noise);
src/engine/load_file.c:  i = -1;
src/engine/load_file.c:  if (load_type(s, ini, ftab, scope) == -1)
src/engine/load_file.c:    return (-1);
src/engine/load_file.c:  s->eye.pos.x = (double)my_getnbr((char *)field);
src/engine/load_file.c:  s->eye.pos.y = (double)my_getnbr((char *)field);
src/engine/load_file.c:  s->eye.pos.z = (double)my_getnbr((char *)field);
src/engine/load_file.c:  s->eye.rot.x = my_getnbr((char *)field);
src/engine/load_file.c:  s->eye.rot.y = my_getnbr((char *)field);
src/engine/load_file.c:  s->eye.rot.z = my_getnbr((char *)field);
src/engine/load_file.c:  s->opt.skybox_down_tex_name = my_strdup((char *)field);
src/engine/load_file.c:  if ((s->opt.skybox_down = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_file.c:  s->opt.skybox_front_tex_name = my_strdup((char *)field);
src/engine/load_file.c:  if ((s->opt.skybox_forward = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_file.c:  s->opt.skybox_back_tex_name = my_strdup((char *)field);
src/engine/load_file.c:  if ((s->opt.skybox_backward = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_file.c:  s->opt.skybox_right_tex_name = my_strdup((char *)field);
src/engine/load_file.c:  if ((s->opt.skybox_right = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_file.c:  s->opt.skybox_left_tex_name = my_strdup((char *)field);
src/engine/load_file.c:  if ((s->opt.skybox_left = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_file.c:  s->opt.skybox_up_tex_name = my_strdup((char *)field);
src/engine/load_file.c:  if ((s->opt.skybox_up = bunny_load_pixelarray((char *)field)) == NULL)
src/engine/load_file.c:  s->opt.ss = my_getnbr((char *)field);
src/engine/load_file.c:  if (s->opt.ss == 1)
src/engine/load_file.c:      s->opt.nb_rays_ss = my_getnbr((char *)field);
src/engine/load_file.c:      s->opt.ray_ss = my_getnbr((char *)field);
src/engine/load_file.c:      s->opt.nb_rays_ss = 1;
src/engine/load_file.c:      s->opt.ray_ss = 0;
src/engine/load_file.c:  if (load_shadow_params(s, ini) == -1)
src/engine/load_file.c:    return (-1);
src/engine/load_file.c:  s->opt.ambient = (double)my_getnbr((char *)field) / 100.0;
src/engine/load_file.c:  s->opt.aa = my_getnbr((char *)field);
src/engine/load_file.c:  s->opt.ambient_refraction = atof((char *)field);
src/engine/load_file.c:  aa = sqrt(s->opt.aa);
src/engine/load_file.c:      s->opt.skybox = 0;
src/engine/load_file.c:  s->opt.skybox = my_getnbr((char *)field);
src/engine/load_file.c:  s->obj = NULL;
src/engine/load_file.c:  if (load_eye(s, ini) == -1)
src/engine/load_file.c:    return (-1);
src/engine/load_file.c:  if (load_scene_parameters(s, ini) == -1)
src/engine/load_file.c:    return (-1);
src/engine/load_file.c:      if (load_object(s, ini, (char *)field) == -1)
src/engine/load_file.c:	return (-1);
src/engine/load_file.c:  s->obj_hit = NULL;
src/engine/init_noise.c:  while (--i)
src/engine/init_noise.c:  i = -1;
src/engine/init_noise.c:      j = -1;
src/engine/init_noise.c:      j = -1;
src/engine/init_noise.c:  i  = -1;
src/engine/init_noise.c:      g1[i] = (double)((random() % (B + B)) - B) / B;
src/engine/init_noise.c:      j = -1;
src/engine/init_noise.c:	g2[i][j] = (double)((random() % (B + B)) - B) / B;
src/engine/init_noise.c:      j = -1;
src/engine/init_noise.c:	g3[i][j] = (double)((random() % (B + B)) - B) / B;
src/engine/clear_list.c:  it = root->next;
src/engine/clear_list.c:  while (it->next != NULL)
src/engine/clear_list.c:      it = it->next;
src/engine/clear_list.c:      bunny_free(it->prev);
src/engine/texturize_obj.c:  s->final_color = s->hit.color1;
src/engine/texturize_obj.c:  color = s->hit.texture1->pixels;
src/engine/texturize_obj.c:  s->hit.texels.x = s->hit.texels.x
src/engine/texturize_obj.c:    * s->hit.texture1->clipable.clip_width;
src/engine/texturize_obj.c:  s->hit.texels.y = s->hit.texels.y
src/engine/texturize_obj.c:    * s->hit.texture1->clipable.clip_height;
src/engine/texturize_obj.c:  s->final_color = color[s->hit.texture1->clipable.clip_width
src/engine/texturize_obj.c:			 * (int)s->hit.texels.y
src/engine/texturize_obj.c:			 + (int)s->hit.texels.x];
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[0] = &full_color;
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[1] = &stripes;
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[2] = &checkerboard_2d;
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[3] = &planar_checkerboard;
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[4] = &checkerboard_3d;
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[5] = &smooth_noise;
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[6] = &marble_noise;
src/engine/texturize_obj.c:  s->ftabs.tex_ftab[7] = &get_image_texel;
src/engine/texturize_obj.c:  if (s->hit.tex_type < 9)
src/engine/texturize_obj.c:    s->ftabs.tex_ftab[s->hit.tex_type - 1](s);
src/engine/texturize_obj.c:    s->ftabs.tex_ftab[0](s);
src/engine/perlin.c:  *r0 = t - (int)t;
src/engine/perlin.c:  *r1 = *r0 - 1.0;
src/engine/perlin.c:  while (--i)
src/engine/perlin.c:  i = -1;
src/engine/perlin.c:      j = -1;
src/engine/perlin.c:      j = -1;
src/engine/perlin.c:  i  = -1;
src/engine/perlin.c:      g1[i] = (double)((random() % (B + B)) - B) / B;
src/engine/perlin.c:      j = -1;
src/engine/perlin.c:	g2[i][j] = (double)((random() % (B + B)) - B) / B;
src/engine/perlin.c:      j = -1;
src/engine/perlin.c:	g3[i][j] = (double)((random() % (B + B)) - B) / B;
src/engine/perlin.c:   i = -1;
src/engine/order_hit_list.c:  it_prev->prev->next = it;
src/engine/order_hit_list.c:  if (it->next != NULL)
src/engine/order_hit_list.c:    it->next->prev = it_prev;
src/engine/order_hit_list.c:  it_prev->next = it->next;
src/engine/order_hit_list.c:  it->prev = it_prev->prev;
src/engine/order_hit_list.c:  it->next = it_prev;
src/engine/order_hit_list.c:  it_prev->prev = it;
src/engine/order_hit_list.c:  if (root == NULL || root->next == NULL || root->next->next == NULL)
src/engine/order_hit_list.c:  it = root->next->next;
src/engine/order_hit_list.c:  it_prev = root->next;
src/engine/order_hit_list.c:      if (it->k < it_prev->k)
src/engine/order_hit_list.c:	  return (-1);
src/engine/order_hit_list.c:      it = it->next;
src/engine/order_hit_list.c:      it_prev = it_prev->next;
src/engine/order_hit_list.c:  while (order_list(root) == -1);
src/engine/limited_plan.c:  if (s->hit.simple_inter1.y < - plan->height / 2 ||
src/engine/limited_plan.c:      s->hit.simple_inter1.y > plan->height / 2 ||
src/engine/limited_plan.c:      s->hit.simple_inter1.x < - plan->width / 2 ||
src/engine/limited_plan.c:      s->hit.simple_inter1.x > plan->width / 2)
src/engine/limited_plan.c:    return (-1);
src/engine/get_norm.c:  s->hit.norm.x = 0;
src/engine/get_norm.c:  s->hit.norm.y = 0;
src/engine/get_norm.c:  s->hit.norm.z = -100;
src/engine/get_norm.c:  end_rotation(&s->rotation, &s->hit.norm, &plan->rot);
src/engine/get_norm.c:  s->hit.norm.x = s->hit.simple_inter1.x;
src/engine/get_norm.c:  s->hit.norm.y = s->hit.simple_inter1.y;
src/engine/get_norm.c:  s->hit.norm.z = s->hit.simple_inter1.z;
src/engine/get_norm.c:  s->hit.norm.x = s->hit.simple_inter1.x;
src/engine/get_norm.c:  s->hit.norm.y = s->hit.simple_inter1.y;
src/engine/get_norm.c:  s->hit.norm.z = 0;
src/engine/get_norm.c:  end_rotation(&s->rotation, &s->hit.norm, &cylinder->rot);
src/engine/get_norm.c:  s->hit.norm.x = s->hit.simple_inter1.x;
src/engine/get_norm.c:  s->hit.norm.y = s->hit.simple_inter1.y;
src/engine/get_norm.c:  s->hit.norm.z = - 0.1 * s->hit.simple_inter1.z;
src/engine/get_norm.c:  end_rotation(&s->rotation, &s->hit.norm, &cone->rot);
src/engine/shadow.c:  if (obj->datas == s->obj_hit->next->datas)
src/engine/shadow.c:  shape = (t_sphere *)obj->datas;
src/engine/shadow.c:      s->shade.shadow.coef += shape->opacity;
src/engine/shadow.c:  if (obj->datas == s->obj_hit->next->datas)
src/engine/shadow.c:  shape = (t_cone *)obj->datas;
src/engine/shadow.c:      s->shade.shadow.coef += shape->opacity;
src/engine/shadow.c:  if (obj->datas == s->obj_hit->next->datas)
src/engine/shadow.c:  shape = (t_cylinder *)obj->datas;
src/engine/shadow.c:      s->shade.shadow.coef += shape->opacity;
src/engine/shadow.c:  if (obj->datas == s->obj_hit->next->datas)
src/engine/shadow.c:  shape = (t_plan *)obj->datas;
src/engine/shadow.c:      s->shade.shadow.coef += shape->opacity;
src/engine/shadow.c:  s->ftabs.shadow_ftab[0] = &shadow_sphere;
src/engine/shadow.c:  s->ftabs.shadow_ftab[1] = &shadow_cylinder;
src/engine/shadow.c:  s->ftabs.shadow_ftab[2] = &shadow_cone;
src/engine/shadow.c:  s->ftabs.shadow_ftab[3] = &shadow_plan;
src/engine/shadow.c:  it = s->obj;
src/engine/shadow.c:  s->shade.shadow.coef = 0;
src/engine/shadow.c:      if (it->type > 1)
src/engine/shadow.c:	s->ftabs.shadow_ftab[it->type - 2](s, it);
src/engine/shadow.c:      if (s->shade.shadow.coef >= 1)
src/engine/shadow.c:      it = it->next;
src/interface/init_ftabs.c:  itfc->fct_context[0] = modif_form;
src/interface/init_ftabs.c:  itfc->fct_context[1] = add_form;
src/interface/init_ftabs.c:  itfc->fct_context[2] = sub_form;
src/interface/init_ftabs.c:  itfc->fct_context[3] = spotlight;
src/interface/init_ftabs.c:  itfc->fct_context[4] = new_scene;
src/interface/init_ftabs.c:  itfc->fct_context[5] = filters;
src/interface/init_ftabs.c:  itfc->fct_context[6] = gen_opt;
src/interface/init_ftabs.c:  itfc->fct_context[7] = save;
src/interface/init_ftabs.c:  itfc->fct_button[0] = open_file;
src/interface/init_ftabs.c:  itfc->fct_button[1] = help;
src/interface/init_ftabs.c:  itfc->fct_button[2] = render;
src/interface/init_ftabs.c:  itfc->fct_button[3] = live;
src/interface/init_ftabs.c:  itfc->fct_state[0] = mouse_state;
src/interface/init_ftabs.c:  itfc->fct_state[1] = move_state;
src/interface/init_ftabs.c:  itfc->fct_state[2] = rotate_state;
src/interface/init_ftabs.c:  itfc->save.need_save = false;
src/interface/init_ftabs.c:  itfc->save.curs = 0;
src/interface/init_ftabs.c:  if ((itfc->save.file =
src/interface/init_ftabs.c:  my_bzero(itfc->save.file, FILE_LEN + 1);
src/interface/init_ftabs.c:  itfc->save.save_state = NOTHING;
src/interface/init_ftabs.c:  itfc->save.fct_save[0] = nothing_selected;
src/interface/init_ftabs.c:  itfc->save.fct_save[1] = save_png;
src/interface/init_ftabs.c:  itfc->save.fct_save[2] = save_jpg;
src/interface/init_ftabs.c:  itfc->save.fct_save[3] = save_bmp;
src/interface/init_ftabs.c:  itfc->save.fct_save[4] = save_ini;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_name[0] = sphere_name;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_name[1] = cylinder_name;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_name[2] = cone_name;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_name[3] = plane_name;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_name[4] = light_name;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_obj[0] = sphere_obj;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_obj[1] = cylinder_obj;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_obj[2] = cone_obj;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_obj[3] = plane_obj;
src/interface/init_ftabs.c:  itfc->save.fct_save_ini_obj[4] = light_obj;
src/interface/init_ftabs.c:  itfc->fct_set_size[0] = set_full_size;
src/interface/init_ftabs.c:  itfc->fct_set_size[1] = set_high_size;
src/interface/init_ftabs.c:  itfc->fct_set_size[2] = set_hd_size;
src/interface/init_ftabs.c:  itfc->fct_set_size[3] = set_xga_size;
src/interface/init_ftabs.c:  itfc->fct_set_size[4] = set_vga_size;
src/interface/init_ftabs.c:    itfc->button[i++] = false;
src/interface/init_ftabs.c:  itfc->button[0] = true;
src/interface/init_ftabs.c:  itfc->status = S_MOUSE;
src/interface/check_bt_activated.c:** That also set itfc->status on the right enum
src/interface/check_bt_activated.c:      if (itfc->button[i])
src/interface/check_bt_activated.c:	  if (itfc->fct_context[i - 1](data) == 1)
src/interface/check_bt_activated.c:	  return (-1);
src/interface/check_bt_activated.c:      if (itfc->button[i])
src/interface/check_bt_activated.c:	  if (itfc->rendering && (i != LIVE && i != HELP))
src/interface/check_bt_activated.c:	  if (itfc->fct_button[n](data) == 1)
src/interface/check_bt_activated.c:  if (itfc->button[0])
src/interface/check_bt_activated.c:  if (data->rt.live && (i = check_context_activated(itfc, data)) == 1)
src/interface/check_bt_activated.c:  if (i == -1)
src/interface/rotate_eye.c:  if (!data->itfc.move.needmoving)
src/interface/rotate_eye.c:      data->itfc.move.first_pos = *mpos;
src/interface/rotate_eye.c:      data->itfc.move.needmoving = true;
src/interface/rotate_eye.c:      data->itfc.move.second_pos = *mpos;
src/interface/rotate_eye.c:      data->rt.eye.rot.y +=
src/interface/rotate_eye.c:	((data->itfc.move.second_pos.x - data->itfc.move.first_pos.x) / 3);
src/interface/rotate_eye.c:      data->rt.eye.rot.x -=
src/interface/rotate_eye.c:	((data->itfc.move.second_pos.y - data->itfc.move.first_pos.y) / 3);
src/interface/rotate_eye.c:      data->itfc.move.first_pos = data->itfc.move.second_pos;
src/interface/rotate_eye.c:  rt = &data->rt;
src/interface/rotate_eye.c:  mpos = data->itfc.mpos;
src/interface/rotate_eye.c:  if (mpos->x > ((((MAX_WORK_SPACE_X - WORK_SPACE_X) / 2) + WORK_SPACE_X) -
src/interface/rotate_eye.c:		 (rt->img->clipable.clip_width / 2))
src/interface/rotate_eye.c:      && mpos->x < ((((MAX_WORK_SPACE_X - WORK_SPACE_X) / 2) + WORK_SPACE_X) -
src/interface/rotate_eye.c:  		    (rt->img->clipable.clip_width / 2) + rt->img->clipable.clip_width)
src/interface/rotate_eye.c:      && mpos->y > ((((MAX_WORK_SPACE_Y - WORK_SPACE_Y) / 2) + WORK_SPACE_Y) -
src/interface/rotate_eye.c:  		    (rt->img->clipable.clip_height / 2))
src/interface/rotate_eye.c:      && mpos->y < ((((MAX_WORK_SPACE_Y - WORK_SPACE_Y) / 2) + WORK_SPACE_Y) -
src/interface/rotate_eye.c:  		    (rt->img->clipable.clip_height / 2)) + rt->img->clipable.clip_height)
src/interface/rotate_state.c:  if (data->rt.img != NULL)
src/interface/rotate_state.c:	  data->itfc.left_click = true;
src/interface/rotate_state.c:	  data->itfc.move.needmoving = false;
src/interface/rotate_state.c:	  data->itfc.left_click = false;
src/interface/rotate_state.c:	  data->itfc.move.needmoving = false;
src/interface/check_menu_buttons.c:      if (mpos->x >= BT_X && mpos->x <= BT_X + BT_WDT
src/interface/check_menu_buttons.c:	  && mpos->y >= BT_Y + (BT_HGT * (nb_bt - 1))
src/interface/check_menu_buttons.c:	  && mpos->y <= BT_Y + BT_HGT + (BT_HGT * (nb_bt - 1)))
src/interface/check_menu_buttons.c:	  if (!itfc->button[nb_bt])
src/interface/check_menu_buttons.c:	      itfc->button[nb_bt] = true;
src/interface/check_menu_buttons.c:	      itfc->act_context = nb_bt;
src/interface/check_menu_buttons.c:	      itfc->button[0] = true;
src/interface/check_menu_buttons.c:	      itfc->act_context = 0;
src/interface/check_menu_buttons.c:      if (mpos->x >= BT_X && mpos->x <= BT_X + BT_WDT
src/interface/check_menu_buttons.c:	  && mpos->y >= BT2_Y + (BT_HGT * (nb_bt - 5))
src/interface/check_menu_buttons.c:	  && mpos->y <= BT2_Y + BT_HGT + (BT_HGT * (nb_bt - 5)))
src/interface/check_menu_buttons.c:	  if (!itfc->button[nb_bt])
src/interface/check_menu_buttons.c:	      itfc->button[nb_bt] = true;
src/interface/check_menu_buttons.c:	      itfc->act_context = nb_bt;
src/interface/check_menu_buttons.c:	      itfc->button[0] = true;
src/interface/check_menu_buttons.c:	      itfc->act_context = 0;
src/interface/move_eye.c:    translation(&data->rt.rotation, &vec,
src/interface/move_eye.c:		&data->rt.eye.rot,
src/interface/move_eye.c:		&data->rt.eye.pos);
src/interface/move_eye.c:  else if (delta == -1 && wheelid == 1)
src/interface/move_eye.c:      vec.x = -300;
src/interface/move_eye.c:      translation(&data->rt.rotation,
src/interface/move_eye.c:		  &vec, &data->rt.eye.rot,
src/interface/move_eye.c:		  &data->rt.eye.pos);
src/interface/move_eye.c:  if (!data->itfc.move.needmoving)
src/interface/move_eye.c:      data->itfc.move.first_pos = *mpos;
src/interface/move_eye.c:      data->itfc.move.needmoving = true;
src/interface/move_eye.c:      data->itfc.move.second_pos = *mpos;
src/interface/move_eye.c:	(data->itfc.move.second_pos.x - data->itfc.move.first_pos.x) * 10;
src/interface/move_eye.c:	(data->itfc.move.second_pos.y - data->itfc.move.first_pos.y) * 10;
src/interface/move_eye.c:      translation(&data->rt.rotation, &vec,
src/interface/move_eye.c:		  &data->rt.eye.rot, &data->rt.eye.pos);
src/interface/move_eye.c:      data->itfc.move.first_pos = data->itfc.move.second_pos;
src/interface/move_eye.c:  rt = &data->rt;
src/interface/move_eye.c:  mpos = data->itfc.mpos;
src/interface/move_eye.c:  if (mpos->x > ((((MAX_WORK_SPACE_X - WORK_SPACE_X) / 2) + WORK_SPACE_X) -
src/interface/move_eye.c:  		(rt->img->clipable.clip_width / 2))
src/interface/move_eye.c:      && mpos->x < ((((MAX_WORK_SPACE_X - WORK_SPACE_X) / 2) + WORK_SPACE_X) -
src/interface/move_eye.c:  		    (rt->img->clipable.clip_width / 2) + rt->img->clipable.clip_width)
src/interface/move_eye.c:      && mpos->y > ((((MAX_WORK_SPACE_Y - WORK_SPACE_Y) / 2) + WORK_SPACE_Y) -
src/interface/move_eye.c:  		    (rt->img->clipable.clip_height / 2))
src/interface/move_eye.c:      && mpos->y < ((((MAX_WORK_SPACE_Y - WORK_SPACE_Y) / 2) + WORK_SPACE_Y) -
src/interface/move_eye.c:  		    (rt->img->clipable.clip_height / 2)) + rt->img->clipable.clip_height)
src/interface/buttons.c:  if (!data->itfc.rendering && !data->itfc.rendered)
src/interface/buttons.c:      data->itfc.rendering = true;
src/interface/buttons.c:      data->rt.live = false;
src/interface/buttons.c:  data->rt.live = true;
src/interface/buttons.c:  data->itfc.rendered = false;
src/interface/buttons.c:  data->itfc.rendering = false;
src/interface/buttons.c:  data->ld.loading->clipable.clip_width = 0;
src/interface/init_itfc.c:  if ((itfc->layout =
src/interface/init_itfc.c:      (itfc->context[0] =
src/interface/init_itfc.c:      (itfc->context[1] =
src/interface/init_itfc.c:      (itfc->context[2] =
src/interface/init_itfc.c:      (itfc->context[3] =
src/interface/init_itfc.c:      (itfc->context[4] =
src/interface/init_itfc.c:      (itfc->context[5] =
src/interface/init_itfc.c:      (itfc->context[6] =
src/interface/init_itfc.c:      (itfc->context[7] =
src/interface/init_itfc.c:      (itfc->context[8] =
src/interface/init_itfc.c:      (itfc->curs = bunny_load_picture("assets/img/curs.png")) == NULL)
src/interface/init_itfc.c:  itfc->open.need_open = false;
src/interface/init_itfc.c:  itfc->open.curs = 0;
src/interface/init_itfc.c:  if ((itfc->open.file =
src/interface/init_itfc.c:  my_bzero(itfc->open.file, FILE_LEN + 1);
src/interface/init_itfc.c:  if (data->rt.opt.aa <= 1)
src/interface/init_itfc.c:    itfc->gen.pos_curs_aa.x = (int)itfc->gen.acc_curs_aa.x +
src/interface/init_itfc.c:      if (data->rt.opt.aa == i)
src/interface/init_itfc.c:	itfc->gen.pos_curs_aa.x = (int)itfc->gen.acc_curs_aa.x +
src/interface/init_itfc.c:  itfc->gen.acc_curs_amb.x = START_SLIDE_AMB_X +
src/interface/init_itfc.c:    data->rt.opt.ambient * 175;
src/interface/init_itfc.c:  itfc->gen.acc_curs_amb.y = START_SLIDE_AMB_Y + HALF_CURS_Y;
src/interface/init_itfc.c:  itfc->gen.pos_curs_amb.x = (int)itfc->gen.acc_curs_amb.x;
src/interface/init_itfc.c:  itfc->gen.pos_curs_amb.y = (int)itfc->gen.acc_curs_amb.y;
src/interface/init_itfc.c:  itfc->gen.acc_curs_aa.x = START_SLIDE_AA_X;
src/interface/init_itfc.c:  itfc->gen.acc_curs_aa.y = START_SLIDE_AA_Y + HALF_CURS_Y;
src/interface/init_itfc.c:  itfc->gen.pos_curs_aa.y = (int)itfc->gen.acc_curs_aa.y;
src/interface/init_itfc.c:  itfc->gen.needmoving = false;
src/interface/init_itfc.c:  itfc->layout = NULL;
src/interface/init_itfc.c:  if (init_pix(itfc) == -1 || init_ftabs(itfc) == 1
src/interface/init_itfc.c:    return (-1);
src/interface/init_itfc.c:  itfc->act_context = 0;
src/interface/init_itfc.c:  itfc->context_pos.x = 131;
src/interface/init_itfc.c:  itfc->context_pos.y = 70;
src/interface/init_itfc.c:  itfc->rendering = false;
src/interface/init_itfc.c:  itfc->rendered = false;
src/interface/init_itfc.c:  itfc->move.needmoving = false;
src/interface/init_itfc.c:  itfc->left_click = false;
src/interface/init_itfc.c:  if ((itfc->txt.font =
src/interface/init_itfc.c:  if ((itfc->past.img =
src/interface/init_itfc.c:  itfc->past.pos.x = 0;
src/interface/init_itfc.c:  itfc->past.pos.y = 0;
src/interface/zoom.c:    translation(&data->rt.rotation,
src/interface/zoom.c:		&data->rt.eye.rot,
src/interface/zoom.c:		&data->rt.eye.pos);
src/interface/zoom.c:  else if (delta == -1 && wheelid == 0)
src/interface/zoom.c:      vec.z = -500;
src/interface/zoom.c:      translation(&data->rt.rotation,
src/interface/zoom.c:		  &vec, &data->rt.eye.rot,
src/interface/zoom.c:		  &data->rt.eye.pos);
src/interface/rendering.c:  if (data->rt.img != NULL)
src/interface/rendering.c:      fill_pxlarray(data->rt.img, 0xFF262626);
src/interface/rendering.c:      data->rt.nb_coef = 1;
src/interface/rendering.c:      data->ld.nb_coef = 1;
src/interface/rendering.c:      data->ld.curr_line = 0;
src/interface/rendering.c:      data->rt.r_pos.y = 0;
src/interface/rendering.c:      data->ld.save_width = data->ld.loading->clipable.clip_width;
src/interface/rendering.c:      data->ld.loading->clipable.clip_width = 1;
src/interface/rendering.c:      if ((data->rt.shade.itab =
src/interface/rendering.c:	   bunny_malloc(sizeof(double) * data->rt.opt.nb_rays_ss)) == NULL)
src/interface/rendering.c:      display(&data->rt, data);
src/interface/check_file_buttons.c:  if (mpos->x >= BT_SAVE_X && mpos->x <= BT_SAVE_X + SAVE_WDT
src/interface/check_file_buttons.c:      && mpos->y >= BT_SAVE_Y && mpos->y <= BT_EXIT_Y + SAVE_HGT)
src/interface/check_file_buttons.c:      if (!itfc->button[nb_bt])
src/interface/check_file_buttons.c:	  itfc->button[nb_bt] = true;
src/interface/check_file_buttons.c:	  itfc->act_context = nb_bt;
src/interface/check_file_buttons.c:	  itfc->button[0] = true;
src/interface/check_file_buttons.c:	  itfc->act_context = 0;
src/interface/check_file_buttons.c:      if (mpos->x >= BT_SAVE_X + (SAVE_WDT * (nb_bt - 8)) + 5
src/interface/check_file_buttons.c:	  && mpos->x <= BT_SAVE_X + SAVE_WDT + (SAVE_WDT * (nb_bt - 8)) + 5
src/interface/check_file_buttons.c:	  && mpos->y >= BT_SAVE_Y
src/interface/check_file_buttons.c:	  && mpos->y <= BT_SAVE_Y + SAVE_HGT)
src/interface/check_file_buttons.c:	  if (!itfc->button[nb_bt])
src/interface/check_file_buttons.c:	      itfc->button[nb_bt] = true;
src/interface/check_file_buttons.c:	      itfc->act_context = 0;
src/interface/interface.c:  if (data->itfc.status == S_MOUSE)
src/interface/interface.c:      /* printf("STATUS -> MOUSE\n"); */
src/interface/interface.c:  else if (data->itfc.status == S_MOVE)
src/interface/interface.c:      /* printf("STATUS -> MOVE\n"); */
src/interface/interface.c:      if (data->itfc.left_click)
src/interface/interface.c:  else if (data->itfc.status == S_ROTATE)
src/interface/interface.c:      /* printf("STATUS -> ROTATE\n"); */
src/interface/interface.c:      if (data->itfc.left_click)
src/interface/interface.c:  data->itfc.live = data->rt.live;
src/interface/interface.c:  if (data->itfc.button[SAVE])
src/interface/interface.c:    data->itfc.save.fct_save[data->itfc.save.save_state](data);
src/interface/interface.c:  else if (data->itfc.button[OPEN])
src/interface/interface.c:  if (data->itfc.button[NO_BUTTON] || data->itfc.rendered)
src/interface/interface.c:    data->itfc.fct_bt_context = nothing_selected;
src/interface/interface.c:  if (data->rt.live && data->itfc.fct_bt_context(data) == 1)
src/interface/interface.c:  /* debug_tabbool(data->itfc.button); */
src/interface/interface.c:  /* printf("STATUS => %d\n", data->itfc.status); */
src/interface/text.c:  ch -= 32;
src/interface/text.c:    font->clip_x_position = 0;
src/interface/text.c:    font->clip_x_position = ((ch - 1) * size_x) + decalx;
src/interface/text.c:  font->clip_width = size_x;
src/interface/text.c:  font->clip_y_position = (line * SIZE_Y) + FIRST_Y;
src/interface/text.c:  font->clip_height = SIZE_Y;
src/interface/text.c:  bunny_blit(&text->win->buffer, font, &text->txt_pos);
src/interface/text.c:  text->txt_pos.x += size_x;
src/interface/text.c:  itfc->txt.txt_pos.x = x;
src/interface/text.c:  itfc->txt.txt_pos.y = y;
src/interface/text.c:      blit_char(&itfc->txt, itfc->txt.font, str[i]);
src/interface/text.c:    blit_char(&itfc->txt, itfc->txt.font, '|');
src/interface/text.c:  if (data->itfc.button[SAVE])
src/interface/text.c:      if (unicode == DELETE && data->itfc.save.curs > 0)
src/interface/text.c:	data->itfc.save.file[--data->itfc.save.curs] = 0;
src/interface/text.c:      else if (unicode == RETURN && data->itfc.save.curs > 0)
src/interface/text.c:	data->itfc.save.need_save = true;
src/interface/text.c:      else if (data->itfc.save.curs < FILE_LEN)
src/interface/text.c:	data->itfc.save.file[data->itfc.save.curs++] = unicode;
src/interface/text.c:  else if (data->itfc.button[OPEN])
src/interface/text.c:      if (unicode == DELETE && data->itfc.open.curs > 0)
src/interface/text.c:	data->itfc.open.file[--data->itfc.open.curs] = 0;
src/interface/text.c:	data->itfc.open.need_open = true;
src/interface/text.c:      else if (data->itfc.open.curs < FILE_LEN)
src/interface/text.c:	data->itfc.open.file[data->itfc.open.curs++] = unicode;
src/interface/check_buttons.c:** -> itfc->button[] which is set on true only for the button currently
src/interface/check_buttons.c:      if (mpos->x >= OPT_X + (OPT_WDT * (nb_bt - 11)) + 7 * (nb_bt - 11)
src/interface/check_buttons.c:	  && mpos->x <= OPT_X + OPT_WDT + (OPT_WDT * (nb_bt - 11)) + 7 * (nb_bt - 11)
src/interface/check_buttons.c:	  && mpos->y >= OPT_Y
src/interface/check_buttons.c:	  && mpos->y <= OPT_Y + OPT_HGT)
src/interface/check_buttons.c:	  if (!itfc->button[nb_bt])
src/interface/check_buttons.c:	      itfc->button[nb_bt] = true;
src/interface/check_buttons.c:	      itfc->status = nb_bt - START_STATUS;
src/interface/check_buttons.c:      if (mpos->x >= OPT_X + (OPT_WDT * (nb_bt - 11)) + 7 * (nb_bt - 11)
src/interface/check_buttons.c:	  && mpos->x <= OPT_X + OPT_WDT + (OPT_WDT * (nb_bt - 11)) + 7 * (nb_bt - 11)
src/interface/check_buttons.c:	  && mpos->y >= OPT_Y
src/interface/check_buttons.c:	  && mpos->y <= OPT_Y + OPT_HGT)
src/interface/check_buttons.c:	  if (!itfc->button[nb_bt])
src/interface/check_buttons.c:	      itfc->button[nb_bt] = true;
src/interface/check_buttons.c:	      itfc->act_context = 0;
src/interface/check_buttons.c:  if (mpos->x >= BT_EXIT_X && mpos->x <= BT_EXIT_X + EXIT_WDT
src/interface/check_buttons.c:      && mpos->y >= BT_EXIT_Y && mpos->y <= BT_EXIT_Y + EXIT_HGT)
src/interface/check_buttons.c:  itfc->mpos = bunny_get_mouse_position();
src/interface/check_buttons.c:  form_button(itfc, itfc->mpos);
src/interface/check_buttons.c:  gen_button(itfc, itfc->mpos);
src/interface/check_buttons.c:  save_button(itfc, itfc->mpos);
src/interface/check_buttons.c:  file_button(itfc, itfc->mpos);
src/interface/check_buttons.c:  opt_button(itfc, itfc->mpos);
src/interface/check_buttons.c:  if (exit_button(itfc, itfc->mpos) == 1)
src/interface/open_file.c:  data->itfc.open.need_open = false;
src/interface/open_file.c:  my_bzero(data->itfc.open.file, FILE_LEN);
src/interface/open_file.c:  data->itfc.open.curs = 0;
src/interface/open_file.c:  data->rt.pos = center_rt(&data->rt);
src/interface/open_file.c:  data->itfc.open.need_open = false;
src/interface/open_file.c:  my_bzero(data->itfc.open.file, FILE_LEN);
src/interface/open_file.c:  data->rt.live = true;
src/interface/open_file.c:  fill_pxlarray(data->rt.img, 0xFF262626);
src/interface/open_file.c:  live_display(&data->rt);
src/interface/open_file.c:  data->itfc.open.curs = 0;
src/interface/open_file.c:  if (data->itfc.open.need_open && data->itfc.open.curs > 0)
src/interface/open_file.c:      my_strcat(data->itfc.open.file, ".ini");
src/interface/open_file.c:      name = myrealloc(name, my_strlen(data->itfc.open.file));
src/interface/open_file.c:      my_strcat(name, data->itfc.open.file);
src/interface/open_file.c:      if (load_file(&data->rt, name) == -1)
src/interface/open_file.c:      if (data->rt.img != NULL)
src/interface/open_file.c:	bunny_delete_clipable(&data->rt.img->clipable);
src/interface/open_file.c:      if ((data->rt.img =
src/interface/open_file.c:	   bunny_new_pixelarray(data->rt.width,
src/interface/open_file.c:				data->rt.height)) == NULL)
src/interface/open_file.c:    text(data->itfc.open.file, &data->itfc, TXT_X, TXT_Y);
src/interface/set_bt_false.c:	itfc->button[i] = false;
src/interface/set_bt_false.c:  itfc->button[MOUSE] = false;
src/interface/set_bt_false.c:  itfc->button[MOVE] = false;
src/interface/set_bt_false.c:  itfc->button[ROTATE] = false;
src/interface/context/slide_antialias.c:  if (data->itfc.gen.pos_curs_aa.x < START_SLIDE_AA_X + (20 * 1.75))
src/interface/context/slide_antialias.c:    data->rt.opt.aa = 1;
src/interface/context/slide_antialias.c:  else if (data->itfc.gen.pos_curs_aa.x < START_SLIDE_AA_X + (40 * 1.75))
src/interface/context/slide_antialias.c:    data->rt.opt.aa = 4;
src/interface/context/slide_antialias.c:  else if (data->itfc.gen.pos_curs_aa.x < START_SLIDE_AA_X + (60 * 1.75))
src/interface/context/slide_antialias.c:    data->rt.opt.aa = 8;
src/interface/context/slide_antialias.c:  else if (data->itfc.gen.pos_curs_aa.x < START_SLIDE_AA_X + (80 * 1.75))
src/interface/context/slide_antialias.c:    data->rt.opt.aa = 16;
src/interface/context/slide_antialias.c:  else if (data->itfc.gen.pos_curs_aa.x < START_SLIDE_AA_X + (100 * 1.75))
src/interface/context/slide_antialias.c:    data->rt.opt.aa = 32;
src/interface/context/slide_antialias.c:  if (data->mbutton == BMB_LEFT && data->mstate == GO_DOWN && changing)
src/interface/context/slide_antialias.c:      data->itfc.gen.needmoving = false;
src/interface/context/slide_antialias.c:  if (data->mbutton == BMB_LEFT && data->mstate == GO_UP)
src/interface/context/slide_antialias.c:      data->itfc.gen.needmoving = false;
src/interface/context/slide_antialias.c:  mpos = data->itfc.mpos;
src/interface/context/slide_antialias.c:  if (!data->itfc.gen.needmoving)
src/interface/context/slide_antialias.c:      data->itfc.gen.first_pos = *mpos;
src/interface/context/slide_antialias.c:      data->itfc.gen.needmoving = true;
src/interface/context/slide_antialias.c:      data->itfc.gen.second_pos = *mpos;
src/interface/context/slide_antialias.c:      data->itfc.gen.acc_curs_aa.x += (data->itfc.gen.second_pos.x -
src/interface/context/slide_antialias.c:				       data->itfc.gen.first_pos.x);
src/interface/context/slide_antialias.c:      if (data->itfc.gen.acc_curs_aa.x < START_SLIDE_AA_X)
src/interface/context/slide_antialias.c:	data->itfc.gen.acc_curs_aa.x = START_SLIDE_AA_X;
src/interface/context/slide_antialias.c:      else if (data->itfc.gen.acc_curs_aa.x > END_SLIDE_AA_X)
src/interface/context/slide_antialias.c:	data->itfc.gen.acc_curs_aa.x = END_SLIDE_AA_X;
src/interface/context/slide_antialias.c:      data->itfc.gen.pos_curs_aa.x = (int)data->itfc.gen.acc_curs_aa.x;
src/interface/context/slide_antialias.c:      data->itfc.gen.first_pos = data->itfc.gen.second_pos;
src/interface/context/add_perf_cube.c:  if (data->rt.img != NULL
src/interface/context/add_perf_cube.c:      && data->click_action
src/interface/context/add_perf_cube.c:      && data->itfc.mpos->x > data->rt.pos.x
src/interface/context/add_perf_cube.c:      && data->itfc.mpos->x < data->rt.pos.x +
src/interface/context/add_perf_cube.c:      data->rt.img->clipable.clip_width
src/interface/context/add_perf_cube.c:      && data->itfc.mpos->y > data->rt.pos.y
src/interface/context/add_perf_cube.c:      && data->itfc.mpos->y < data->rt.pos.y +
src/interface/context/add_perf_cube.c:      data->rt.img->clipable.clip_height)
src/interface/context/add_perf_cube.c:      data->click_action = false;
src/interface/context/add_perf_cube.c:    data->click_action = false;
src/interface/context/new_scene.c:    data->itfc.fct_bt_context = create_scene;
src/interface/context/new_scene.c:    data->itfc.fct_bt_context = basic_plane;
src/interface/context/new_scene.c:    data->itfc.fct_bt_context = basic_wallpaper;
src/interface/context/new_scene.c:    data->click_action = true;
src/interface/context/new_scene.c:    data->click_action = false;
src/interface/context/new_scene.c:  mpos = data->itfc.mpos;
src/interface/context/new_scene.c:      if ((i == 0 && mpos->x > NEW_BT_X_FIRST
src/interface/context/new_scene.c:	   && mpos->x < NEW_BT_X_FIRST + NEW_BT_WDT_FIRST
src/interface/context/new_scene.c:	   && mpos->y > NEW_BT_Y_FIRST
src/interface/context/new_scene.c:	   && mpos->y < NEW_BT_Y_FIRST + NEW_BT_HGT_FIRST) ||
src/interface/context/new_scene.c:	  (i > 0 && mpos->x > ADD_BT_X
src/interface/context/new_scene.c:	   && mpos->x < NEW_BT_X + NEW_BT_WDT
src/interface/context/new_scene.c:	   && mpos->y > NEW_BT_Y + (NEW_BT_HGT * (i - 1))
src/interface/context/new_scene.c:	   + (NEW_BT_DECAL * (i - 1))
src/interface/context/new_scene.c:	   && mpos->y < NEW_BT_Y + (NEW_BT_HGT * (i - 1))
src/interface/context/new_scene.c:	   + (NEW_BT_DECAL * (i - 1)) + NEW_BT_HGT))
src/interface/context/save_ini.c:  name = myrealloc(name, my_strlen(data->itfc.save.file));
src/interface/context/save_ini.c:  my_strcat(name, data->itfc.save.file);
src/interface/context/save_ini.c:      data->itfc.save.fct_save_ini_obj
src/interface/context/save_ini.c:	[obj->type - 1 % NB_OBJ](data, obj, ini, i);
src/interface/context/save_ini.c:      obj = obj->next;
src/interface/context/save_ini.c:  act_obj = data->rt.obj;
src/interface/context/save_ini.c:  free_tab(data->itfc.save.obj_names);
src/interface/context/save_ini_obj_scope_light.c:  light = obj->datas;
src/interface/context/save_ini_obj_scope_light.c:  scope = data->itfc.save.obj_names[i];
src/interface/context/save_ini_obj_scope_light.c:  value = setnbr(light->pos.x);
src/interface/context/save_ini_obj_scope_light.c:  value = setnbr(light->pos.y);
src/interface/context/save_ini_obj_scope_light.c:  value = setnbr(light->pos.z);
src/interface/context/save_ini_obj_scope_light.c:  value = setnbr(light->intensity * 100);
src/interface/context/save_ini_obj_scope_light.c:  value = put_base(light->color.full, "0123456789ABCDEF");
src/interface/context/add_cone.c:  con->pos.x = data->rt.eye.pos.x;
src/interface/context/add_cone.c:  con->pos.y = data->rt.eye.pos.y;
src/interface/context/add_cone.c:  con->pos.z = data->rt.eye.pos.z;
src/interface/context/add_cone.c:  translation_obj(&data->rt.rotation,
src/interface/context/add_cone.c:		  &vec, &data->rt.eye.rot, &con->pos);
src/interface/context/add_cone.c:  con->rot.x = 90;
src/interface/context/add_cone.c:  con->rot.y = 0;
src/interface/context/add_cone.c:  con->rot.z = 0;
src/interface/context/add_cone.c:  if (data->rt.obj != NULL)
src/interface/context/add_cone.c:    new = add_obj_elem_ret(data->rt.obj);
src/interface/context/add_cone.c:      data->rt.obj = create_obj_list();
src/interface/context/add_cone.c:      new = data->rt.obj;
src/interface/context/add_cone.c:  con->tex_type = 1;
src/interface/context/add_cone.c:  con->angle = 80;
src/interface/context/add_cone.c:  con->height = 5000;
src/interface/context/add_cone.c:  con->ka = 1.0;
src/interface/context/add_cone.c:  con->kd = 1.0;
src/interface/context/add_cone.c:  con->ks = 1.0;
src/interface/context/add_cone.c:  con->brightness = 0.0;
src/interface/context/add_cone.c:  con->reflection = 0.0;
src/interface/context/add_cone.c:  con->opacity = 1.0;
src/interface/context/add_cone.c:  con->color1.full = OBJ_COLOR;
src/interface/context/add_cone.c:  new->datas = con;
src/interface/context/add_cone.c:  new->type = CONE;
src/interface/context/add_cone.c:  if (data->rt.img != NULL
src/interface/context/add_cone.c:      && data->click_action
src/interface/context/add_cone.c:      && data->itfc.mpos->x > data->rt.pos.x
src/interface/context/add_cone.c:      && data->itfc.mpos->x < data->rt.pos.x +
src/interface/context/add_cone.c:      data->rt.img->clipable.clip_width
src/interface/context/add_cone.c:      && data->itfc.mpos->y > data->rt.pos.y
src/interface/context/add_cone.c:      && data->itfc.mpos->y < data->rt.pos.y +
src/interface/context/add_cone.c:      data->rt.img->clipable.clip_height)
src/interface/context/add_cone.c:      data->click_action = false;
src/interface/context/add_cone.c:    data->click_action = false;
src/interface/context/save.c:  if (data->itfc.save.need_save)
src/interface/context/save.c:      if (data->rt.img == NULL)
src/interface/context/save.c:	  my_strcat(data->itfc.save.file, ".png");
src/interface/context/save.c:	  bunny_save_pixelarray(data->rt.img, data->itfc.save.file);
src/interface/context/save.c:      data->itfc.save.need_save = false;
src/interface/context/save.c:      my_bzero(data->itfc.save.file, FILE_LEN);
src/interface/context/save.c:    text(data->itfc.save.file, &data->itfc, TXT_X, TXT_Y);
src/interface/context/save.c:  if (data->itfc.save.need_save)
src/interface/context/save.c:      if (data->rt.img == NULL)
src/interface/context/save.c:	  my_strcat(data->itfc.save.file, ".jpg");
src/interface/context/save.c:	  bunny_save_pixelarray(data->rt.img, data->itfc.save.file);
src/interface/context/save.c:      data->itfc.save.need_save = false;
src/interface/context/save.c:      my_bzero(data->itfc.save.file, FILE_LEN);
src/interface/context/save.c:    text(data->itfc.save.file, &data->itfc, TXT_X, TXT_Y);
src/interface/context/save.c:  if (data->itfc.save.need_save)
src/interface/context/save.c:      if (data->rt.img == NULL)
src/interface/context/save.c:	  my_strcat(data->itfc.save.file, ".bmp");
src/interface/context/save.c:	  bunny_save_pixelarray(data->rt.img, data->itfc.save.file);
src/interface/context/save.c:      data->itfc.save.need_save = false;
src/interface/context/save.c:      my_bzero(data->itfc.save.file, FILE_LEN);
src/interface/context/save.c:    text(data->itfc.save.file, &data->itfc, TXT_X, TXT_Y);
src/interface/context/save.c:  if (data->itfc.save.need_save)
src/interface/context/save.c:      if (data->rt.img == NULL)
src/interface/context/save.c:	  my_strcat(data->itfc.save.file, ".ini");
src/interface/context/save.c:      data->itfc.save.need_save = false;
src/interface/context/save.c:      my_bzero(data->itfc.save.file, FILE_LEN);
src/interface/context/save.c:    text(data->itfc.save.file, &data->itfc, TXT_X, TXT_Y);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->pos.x);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->pos.y);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->pos.z);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->rot.x);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->rot.y);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->rot.z);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->ka * 100);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->kd * 100);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->ks * 100);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->brightness * 100);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->reflection * 100);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->opacity);
src/interface/context/save_ini_obj_scope_sphere.c:  sph = obj->datas;
src/interface/context/save_ini_obj_scope_sphere.c:  scope = data->itfc.save.obj_names[i];
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->tex_type);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->refraction);
src/interface/context/save_ini_obj_scope_sphere.c:  value = setnbr(sph->size);
src/interface/context/save_ini_obj_scope_sphere.c:  value = put_base(sph->color1.full, "0123456789ABCDEF");
src/interface/context/save_ini_obj_scope_sphere.c:  value = put_base(sph->color2.full, "0123456789ABCDEF");
src/interface/context/add_cylinder.c:  cyl->pos.x = data->rt.eye.pos.x;
src/interface/context/add_cylinder.c:  cyl->pos.y = data->rt.eye.pos.y;
src/interface/context/add_cylinder.c:  cyl->pos.z = data->rt.eye.pos.z;
src/interface/context/add_cylinder.c:  translation_obj(&data->rt.rotation,
src/interface/context/add_cylinder.c:		  &vec, &data->rt.eye.rot, &cyl->pos);
src/interface/context/add_cylinder.c:  cyl->rot.x = 90;
src/interface/context/add_cylinder.c:  cyl->rot.y = 0;
src/interface/context/add_cylinder.c:  cyl->rot.z = 0;
src/interface/context/add_cylinder.c:  if (data->rt.obj != NULL)
src/interface/context/add_cylinder.c:    new = add_obj_elem_ret(data->rt.obj);
src/interface/context/add_cylinder.c:      data->rt.obj = create_obj_list();
src/interface/context/add_cylinder.c:      new = data->rt.obj;
src/interface/context/add_cylinder.c:  cyl->tex_type = 1;
src/interface/context/add_cylinder.c:  cyl->size = 2000;
src/interface/context/add_cylinder.c:  cyl->height = 5000;
src/interface/context/add_cylinder.c:  cyl->ka = 1.0;
src/interface/context/add_cylinder.c:  cyl->kd = 1.0;
src/interface/context/add_cylinder.c:  cyl->ks = 1.0;
src/interface/context/add_cylinder.c:  cyl->brightness = 0.0;
src/interface/context/add_cylinder.c:  cyl->reflection = 0.0;
src/interface/context/add_cylinder.c:  cyl->opacity = 1.0;
src/interface/context/add_cylinder.c:  cyl->color1.full = OBJ_COLOR;
src/interface/context/add_cylinder.c:  new->datas = cyl;
src/interface/context/add_cylinder.c:  new->type = CYLINDER;
src/interface/context/add_cylinder.c:  if (data->rt.img != NULL
src/interface/context/add_cylinder.c:      && data->click_action
src/interface/context/add_cylinder.c:      && data->itfc.mpos->x > data->rt.pos.x
src/interface/context/add_cylinder.c:      && data->itfc.mpos->x < data->rt.pos.x +
src/interface/context/add_cylinder.c:      data->rt.img->clipable.clip_width
src/interface/context/add_cylinder.c:      && data->itfc.mpos->y > data->rt.pos.y
src/interface/context/add_cylinder.c:      && data->itfc.mpos->y < data->rt.pos.y +
src/interface/context/add_cylinder.c:      data->rt.img->clipable.clip_height)
src/interface/context/add_cylinder.c:      data->click_action = false;
src/interface/context/add_cylinder.c:    data->click_action = false;
src/interface/context/add_plane.c:  pla->pos.x = data->rt.eye.pos.x;
src/interface/context/add_plane.c:  pla->pos.y = data->rt.eye.pos.y;
src/interface/context/add_plane.c:  pla->pos.z = data->rt.eye.pos.z;
src/interface/context/add_plane.c:  translation_obj(&data->rt.rotation,
src/interface/context/add_plane.c:		  &vec, &data->rt.eye.rot, &pla->pos);
src/interface/context/add_plane.c:  pla->rot.x = 0;
src/interface/context/add_plane.c:  pla->rot.y = 0;
src/interface/context/add_plane.c:  pla->rot.z = 0;
src/interface/context/add_plane.c:  if (data->rt.obj != NULL)
src/interface/context/add_plane.c:    new = add_obj_elem_ret(data->rt.obj);
src/interface/context/add_plane.c:      data->rt.obj = create_obj_list();
src/interface/context/add_plane.c:      new = data->rt.obj;
src/interface/context/add_plane.c:  pla->tex_type = 1;
src/interface/context/add_plane.c:  pla->width = 500;
src/interface/context/add_plane.c:  pla->height = 500;
src/interface/context/add_plane.c:  pla->ka = 1.0;
src/interface/context/add_plane.c:  pla->kd = 1.0;
src/interface/context/add_plane.c:  pla->ks = 1.0;
src/interface/context/add_plane.c:  pla->brightness = 0.0;
src/interface/context/add_plane.c:  pla->reflection = 0.0;
src/interface/context/add_plane.c:  pla->opacity = 1.0;
src/interface/context/add_plane.c:  pla->color1.full = WHITE;
src/interface/context/add_plane.c:  pla->color2.full = BLACK;
src/interface/context/add_plane.c:  pla->case_size = 2000;
src/interface/context/add_plane.c:  new->datas = pla;
src/interface/context/add_plane.c:  new->type = PLANE;
src/interface/context/add_plane.c:  if (data->rt.img != NULL
src/interface/context/add_plane.c:      && data->click_action
src/interface/context/add_plane.c:      && data->itfc.mpos->x > data->rt.pos.x
src/interface/context/add_plane.c:      && data->itfc.mpos->x < data->rt.pos.x +
src/interface/context/add_plane.c:      data->rt.img->clipable.clip_width
src/interface/context/add_plane.c:      && data->itfc.mpos->y > data->rt.pos.y
src/interface/context/add_plane.c:      && data->itfc.mpos->y < data->rt.pos.y +
src/interface/context/add_plane.c:      data->rt.img->clipable.clip_height)
src/interface/context/add_plane.c:      data->click_action = false;
src/interface/context/add_plane.c:    data->click_action = false;
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->pos.x);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->pos.y);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->pos.z);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->rot.x);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->rot.y);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->rot.z);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->ka * 100);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->kd * 100);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->ks * 100);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->brightness * 100);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->reflection * 100);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->opacity);
src/interface/context/save_ini_obj_scope_cylinder.c:  cyl = obj->datas;
src/interface/context/save_ini_obj_scope_cylinder.c:  scope = data->itfc.save.obj_names[i];
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->tex_type);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->size);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->height);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = setnbr(cyl->refraction);
src/interface/context/save_ini_obj_scope_cylinder.c:  value = put_base(cyl->color1.full, "0123456789ABCDEF");
src/interface/context/save_ini_obj_scope_cylinder.c:  value = put_base(cyl->color2.full, "0123456789ABCDEF");
src/interface/context/save_bt.c:  itfc->save.curs = 0;
src/interface/context/save_bt.c:  my_bzero(itfc->save.file, FILE_LEN);
src/interface/context/save_bt.c:  itfc->save.need_save = false;
src/interface/context/save_bt.c:      itfc->save.save_state = PNG;
src/interface/context/save_bt.c:      itfc->save.save_state = JPG;
src/interface/context/save_bt.c:      itfc->save.save_state = BMP;
src/interface/context/save_bt.c:      itfc->save.save_state = INI;
src/interface/context/save_bt.c:  itfc = &data->itfc;
src/interface/context/save_bt.c:  mpos = data->itfc.mpos;
src/interface/context/save_bt.c:      if (mpos->x > (SAVE_FIRST_BT_X)
src/interface/context/save_bt.c:	  && mpos->x < (SAVE_FIRST_BT_X) + SAVE_FIRST_BT_WDT
src/interface/context/save_bt.c:	  && mpos->y > SAVE_FIRST_BT_Y +
src/interface/context/save_bt.c:	  && mpos->y < (SAVE_FIRST_BT_Y
src/interface/context/add_cube.c:  if (data->rt.img != NULL
src/interface/context/add_cube.c:      && data->click_action
src/interface/context/add_cube.c:      && data->itfc.mpos->x > data->rt.pos.x
src/interface/context/add_cube.c:      && data->itfc.mpos->x < data->rt.pos.x +
src/interface/context/add_cube.c:      data->rt.img->clipable.clip_width
src/interface/context/add_cube.c:      && data->itfc.mpos->y > data->rt.pos.y
src/interface/context/add_cube.c:      && data->itfc.mpos->y < data->rt.pos.y +
src/interface/context/add_cube.c:      data->rt.img->clipable.clip_height)
src/interface/context/add_cube.c:      data->click_action = false;
src/interface/context/add_cube.c:    data->click_action = false;
src/interface/context/add_form.c:    data->itfc.fct_bt_context = add_plane;
src/interface/context/add_form.c:    data->itfc.fct_bt_context = add_sphere;
src/interface/context/add_form.c:    data->itfc.fct_bt_context = add_cone;
src/interface/context/add_form.c:    data->itfc.fct_bt_context = add_cylinder;
src/interface/context/add_form.c:    data->itfc.fct_bt_context = add_cube;
src/interface/context/add_form.c:    data->itfc.fct_bt_context = add_torus;
src/interface/context/add_form.c:    data->itfc.fct_bt_context = add_perf_cube;
src/interface/context/add_form.c:      data->itfc.past.pos.x = PAST_X;
src/interface/context/add_form.c:      data->itfc.past.pos.y = PAST_Y + save * PAST_DECAL_Y;
src/interface/context/add_form.c:      data->wait_click = true;
src/interface/context/add_form.c:    data->itfc.past.pos.x = 0;
src/interface/context/add_form.c:  mpos = data->itfc.mpos;
src/interface/context/add_form.c:      if (mpos->x > ADD_BT_X
src/interface/context/add_form.c:	  && mpos->x < ADD_BT_X + ADD_BT_WDT
src/interface/context/add_form.c:	  && mpos->y > ADD_BT_Y + (ADD_BT_HGT * i) + (ADD_BT_DECAL * i)
src/interface/context/add_form.c:	  && mpos->y < ADD_BT_Y + (ADD_BT_HGT * i)
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_delete_clipable(&data->rt.img->clipable);
src/interface/context/set_size.c:  data->rt.width = FULL_WIDTH;
src/interface/context/set_size.c:  data->rt.height = FULL_HEIGHT;
src/interface/context/set_size.c:  if ((data->rt.img = bunny_new_pixelarray
src/interface/context/set_size.c:       (data->rt.width, data->rt.height)) == NULL)
src/interface/context/set_size.c:  data->rt.pos = center_rt(&data->rt);
src/interface/context/set_size.c:  live_display(&data->rt);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_blit(&data->win->buffer,
src/interface/context/set_size.c:	       &data->rt.img->clipable, &data->rt.pos);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_delete_clipable(&data->rt.img->clipable);
src/interface/context/set_size.c:  data->rt.width = HIGH_WIDTH;
src/interface/context/set_size.c:  data->rt.height = HIGH_HEIGHT;
src/interface/context/set_size.c:  if ((data->rt.img = bunny_new_pixelarray
src/interface/context/set_size.c:       (data->rt.width, data->rt.height)) == NULL)
src/interface/context/set_size.c:  data->rt.pos = center_rt(&data->rt);
src/interface/context/set_size.c:  live_display(&data->rt);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_blit(&data->win->buffer,
src/interface/context/set_size.c:	       &data->rt.img->clipable, &data->rt.pos);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_delete_clipable(&data->rt.img->clipable);
src/interface/context/set_size.c:  data->rt.width = HD_WIDTH;
src/interface/context/set_size.c:  data->rt.height = HD_HEIGHT;
src/interface/context/set_size.c:  if ((data->rt.img = bunny_new_pixelarray
src/interface/context/set_size.c:       (data->rt.width, data->rt.height)) == NULL)
src/interface/context/set_size.c:  data->rt.pos = center_rt(&data->rt);
src/interface/context/set_size.c:  live_display(&data->rt);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_blit(&data->win->buffer,
src/interface/context/set_size.c:	       &data->rt.img->clipable, &data->rt.pos);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_delete_clipable(&data->rt.img->clipable);
src/interface/context/set_size.c:  data->rt.width = XGA_WIDTH;
src/interface/context/set_size.c:  data->rt.height = XGA_HEIGHT;
src/interface/context/set_size.c:  if ((data->rt.img = bunny_new_pixelarray
src/interface/context/set_size.c:       (data->rt.width, data->rt.height)) == NULL)
src/interface/context/set_size.c:  data->rt.pos = center_rt(&data->rt);
src/interface/context/set_size.c:  live_display(&data->rt);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_blit(&data->win->buffer,
src/interface/context/set_size.c:	       &data->rt.img->clipable, &data->rt.pos);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_delete_clipable(&data->rt.img->clipable);
src/interface/context/set_size.c:  data->rt.width = VGA_WIDTH;
src/interface/context/set_size.c:  data->rt.height = VGA_HEIGHT;
src/interface/context/set_size.c:  if ((data->rt.img = bunny_new_pixelarray
src/interface/context/set_size.c:       (data->rt.width, data->rt.height)) == NULL)
src/interface/context/set_size.c:  data->rt.pos = center_rt(&data->rt);
src/interface/context/set_size.c:  live_display(&data->rt);
src/interface/context/set_size.c:  if (data->rt.img != NULL)
src/interface/context/set_size.c:    bunny_blit(&data->win->buffer,
src/interface/context/set_size.c:	       &data->rt.img->clipable, &data->rt.pos);
src/interface/context/slide_ambient.c:	 (data->itfc.gen.pos_curs_amb.x -
src/interface/context/slide_ambient.c:  data->rt.opt.ambient = (data->itfc.gen.pos_curs_amb.x  -
src/interface/context/slide_ambient.c:  if (data->mbutton == BMB_LEFT && data->mstate == GO_DOWN && changing)
src/interface/context/slide_ambient.c:      data->itfc.gen.needmoving = false;
src/interface/context/slide_ambient.c:  if (data->mbutton == BMB_LEFT && data->mstate == GO_UP)
src/interface/context/slide_ambient.c:      data->itfc.gen.needmoving = false;
src/interface/context/slide_ambient.c:  mpos = data->itfc.mpos;
src/interface/context/slide_ambient.c:  if (!data->itfc.gen.needmoving)
src/interface/context/slide_ambient.c:      data->itfc.gen.first_pos = *mpos;
src/interface/context/slide_ambient.c:      data->itfc.gen.needmoving = true;
src/interface/context/slide_ambient.c:      data->itfc.gen.second_pos = *mpos;
src/interface/context/slide_ambient.c:      data->itfc.gen.acc_curs_amb.x += (data->itfc.gen.second_pos.x -
src/interface/context/slide_ambient.c:				       data->itfc.gen.first_pos.x);
src/interface/context/slide_ambient.c:      if (data->itfc.gen.acc_curs_amb.x < START_SLIDE_AMB_X)
src/interface/context/slide_ambient.c:	data->itfc.gen.acc_curs_amb.x = START_SLIDE_AMB_X;
src/interface/context/slide_ambient.c:      else if (data->itfc.gen.acc_curs_amb.x > END_SLIDE_AMB_X)
src/interface/context/slide_ambient.c:	data->itfc.gen.acc_curs_amb.x = END_SLIDE_AMB_X;
src/interface/context/slide_ambient.c:      data->itfc.gen.pos_curs_amb.x = (int)data->itfc.gen.acc_curs_amb.x;
src/interface/context/slide_ambient.c:      data->itfc.gen.first_pos = data->itfc.gen.second_pos;
src/interface/context/add_torus.c:  if (data->rt.img != NULL
src/interface/context/add_torus.c:      && data->click_action
src/interface/context/add_torus.c:      && data->itfc.mpos->x > data->rt.pos.x
src/interface/context/add_torus.c:      && data->itfc.mpos->x < data->rt.pos.x +
src/interface/context/add_torus.c:      data->rt.img->clipable.clip_width
src/interface/context/add_torus.c:      && data->itfc.mpos->y > data->rt.pos.y
src/interface/context/add_torus.c:      && data->itfc.mpos->y < data->rt.pos.y +
src/interface/context/add_torus.c:      data->rt.img->clipable.clip_height)
src/interface/context/add_torus.c:      data->click_action = false;
src/interface/context/add_torus.c:    data->click_action = false;
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->pos.x);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->pos.y);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->pos.z);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->rot.x);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->rot.y);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->rot.z);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->ka * 100);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->kd * 100);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->ks * 100);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->brightness * 100);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->reflection * 100);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->opacity * 100);
src/interface/context/save_ini_obj_scope_plane.c:  pla = obj->datas;
src/interface/context/save_ini_obj_scope_plane.c:  scope = data->itfc.save.obj_names[i];
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->tex_type);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->height * 2);
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->width * 2);
src/interface/context/save_ini_obj_scope_plane.c:  value = put_base(pla->color1.full, "0123456789ABCDEF");
src/interface/context/save_ini_obj_scope_plane.c:  value = put_base(pla->color2.full, "0123456789ABCDEF");
src/interface/context/save_ini_obj_scope_plane.c:  value = setnbr(pla->refraction);
src/interface/context/basic_plane.c:  pla->pos.x = 0;
src/interface/context/basic_plane.c:  pla->pos.y = -20000;
src/interface/context/basic_plane.c:  pla->pos.z = 30000;
src/interface/context/basic_plane.c:  pla->rot.x = 90;
src/interface/context/basic_plane.c:  pla->rot.y = 0;
src/interface/context/basic_plane.c:  pla->rot.z = 0;
src/interface/context/basic_plane.c:  if (data->rt.obj != NULL)
src/interface/context/basic_plane.c:    new = add_obj_elem_ret(data->rt.obj);
src/interface/context/basic_plane.c:      data->rt.obj = create_obj_list();
src/interface/context/basic_plane.c:      new = data->rt.obj;
src/interface/context/basic_plane.c:  pla->tex_type = 1;
src/interface/context/basic_plane.c:  pla->width = 500000;
src/interface/context/basic_plane.c:  pla->height = 500000;
src/interface/context/basic_plane.c:  pla->refraction = 1.0;
src/interface/context/basic_plane.c:  pla->ka = 1.0;
src/interface/context/basic_plane.c:  pla->kd = 1.0;
src/interface/context/basic_plane.c:  pla->ks = 1.0;
src/interface/context/basic_plane.c:  pla->brightness = 0.0;
src/interface/context/basic_plane.c:  pla->reflection = 0.0;
src/interface/context/basic_plane.c:  pla->opacity = 1.0;
src/interface/context/basic_plane.c:  pla->color1.full = WHITE;
src/interface/context/basic_plane.c:  pla->color2.full = BLACK;
src/interface/context/basic_plane.c:  pla->case_size = 2000;
src/interface/context/basic_plane.c:  new->datas = pla;
src/interface/context/basic_plane.c:  new->type = PLANE;
src/interface/context/basic_plane.c:  if (data->rt.img != NULL
src/interface/context/basic_plane.c:      && data->click_action)
src/interface/context/basic_plane.c:      data->click_action = false;
src/interface/context/basic_plane.c:    data->click_action = false;
src/interface/context/create_scene.c:  if (data->click_action)
src/interface/context/create_scene.c:      if (data->rt.img != NULL)
src/interface/context/create_scene.c:	clear_list(data->rt.obj);
src/interface/context/create_scene.c:      if ((data->rt.img =
src/interface/context/create_scene.c:	   bunny_new_pixelarray(data->rt.width,
src/interface/context/create_scene.c:				data->rt.height)) == NULL)
src/interface/context/create_scene.c:      data->rt.eye.pos.x = 0.0;
src/interface/context/create_scene.c:      data->rt.eye.pos.y = 0.0;
src/interface/context/create_scene.c:      data->rt.eye.pos.z = 0.0;
src/interface/context/create_scene.c:      data->rt.eye.rot.x = 0;
src/interface/context/create_scene.c:      data->rt.eye.rot.y = 0;
src/interface/context/create_scene.c:      data->rt.eye.rot.z = 0;
src/interface/context/create_scene.c:      data->rt.opt.ambient = 10.0 / 100.0;
src/interface/context/create_scene.c:      data->rt.opt.ambient_refraction = 1.0;
src/interface/context/create_scene.c:      data->rt.opt.aa = 1;
src/interface/context/create_scene.c:      data->rt.obj_hit = NULL;
src/interface/context/create_scene.c:      data->rt.obj = NULL;
src/interface/context/create_scene.c:      data->click_action = false;
src/interface/context/create_scene.c:      data->rt.pos = center_rt(&data->rt);
src/interface/context/create_scene.c:    data->click_action = false;
src/interface/context/save_ini_first_scope.c:  value = setnbr(data->rt.eye.pos.x);
src/interface/context/save_ini_first_scope.c:  value = setnbr(data->rt.eye.pos.y);
src/interface/context/save_ini_first_scope.c:  value = setnbr(data->rt.eye.pos.z);
src/interface/context/save_ini_first_scope.c:  value = setnbr(data->rt.eye.rot.x);
src/interface/context/save_ini_first_scope.c:  value = setnbr(data->rt.eye.rot.y);
src/interface/context/save_ini_first_scope.c:  value = setnbr(data->rt.eye.rot.z);
src/interface/context/save_ini_first_scope.c:  data->itfc.save.obj_names =
src/interface/context/save_ini_first_scope.c:    my_realloc_tab(data->itfc.save.obj_names, 1);
src/interface/context/save_ini_first_scope.c:  data->itfc.save.obj_names[i] = name;
src/interface/context/save_ini_first_scope.c:  obj = data->rt.obj;
src/interface/context/save_ini_first_scope.c:  if ((data->itfc.save.obj_names = bunny_malloc(sizeof(char *) * 1)) == NULL)
src/interface/context/save_ini_first_scope.c:  data->itfc.save.obj_names[0] = NULL;
src/interface/context/save_ini_first_scope.c:      name = data->itfc.save.fct_save_ini_name
src/interface/context/save_ini_first_scope.c:	[obj->type - 1 % NB_OBJ](data, i);
src/interface/context/save_ini_first_scope.c:      obj = obj->next;
src/interface/context/save_ini_first_scope.c:  value = setnbr((int)(data->rt.opt.ambient * 100));
src/interface/context/save_ini_first_scope.c:  value = setnbr((int)(data->rt.opt.ambient * 100));
src/interface/context/save_ini_first_scope.c:  value = setnbr((int)(data->rt.opt.ambient_refraction));
src/interface/context/save_ini_first_scope.c:  value = setnbr(data->rt.opt.aa);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->pos.x);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->pos.y);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->pos.z);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->rot.x);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->rot.y);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->rot.z);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->ka * 100);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->kd * 100);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->ks * 100);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->brightness * 100);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->reflection * 100);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->opacity);
src/interface/context/save_ini_obj_scope_cone.c:  con = obj->datas;
src/interface/context/save_ini_obj_scope_cone.c:  scope = data->itfc.save.obj_names[i];
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->tex_type);
src/interface/context/save_ini_obj_scope_cone.c:  printf("%d\n", con->angle);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(90 - con->angle);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->height);
src/interface/context/save_ini_obj_scope_cone.c:  value = setnbr(con->refraction);
src/interface/context/save_ini_obj_scope_cone.c:  value = put_base(con->color1.full, "0123456789ABCDEF");
src/interface/context/save_ini_obj_scope_cone.c:  value = put_base(con->color2.full, "0123456789ABCDEF");
src/interface/context/add_sphere.c:  sph->pos.x = data->rt.eye.pos.x;
src/interface/context/add_sphere.c:  sph->pos.y = data->rt.eye.pos.y;
src/interface/context/add_sphere.c:  sph->pos.z = data->rt.eye.pos.z;
src/interface/context/add_sphere.c:  translation_obj(&data->rt.rotation,
src/interface/context/add_sphere.c:		  &vec, &data->rt.eye.rot,
src/interface/context/add_sphere.c:		  &sph->pos);
src/interface/context/add_sphere.c:  sph->rot.x = 0;
src/interface/context/add_sphere.c:  sph->rot.y = 0;
src/interface/context/add_sphere.c:  sph->rot.z = 0;
src/interface/context/add_sphere.c:  if (data->rt.obj != NULL)
src/interface/context/add_sphere.c:    new = add_obj_elem_ret(data->rt.obj);
src/interface/context/add_sphere.c:      data->rt.obj = create_obj_list();
src/interface/context/add_sphere.c:      new = data->rt.obj;
src/interface/context/add_sphere.c:  sph->tex_type = 1;
src/interface/context/add_sphere.c:  sph->size = 1000;
src/interface/context/add_sphere.c:  sph->ka = 1.0;
src/interface/context/add_sphere.c:  sph->kd = 1.0;
src/interface/context/add_sphere.c:  sph->ks = 1.0;
src/interface/context/add_sphere.c:  sph->brightness = 0.0;
src/interface/context/add_sphere.c:  sph->reflection = 0.0;
src/interface/context/add_sphere.c:  sph->opacity = 1.0;
src/interface/context/add_sphere.c:  sph->color1.full = OBJ_COLOR;
src/interface/context/add_sphere.c:  new->datas = sph;
src/interface/context/add_sphere.c:  new->type = SPHERE;
src/interface/context/add_sphere.c:  if (data->rt.img != NULL
src/interface/context/add_sphere.c:      && data->click_action
src/interface/context/add_sphere.c:      && data->itfc.mpos->x > data->rt.pos.x
src/interface/context/add_sphere.c:      && data->itfc.mpos->x < data->rt.pos.x +
src/interface/context/add_sphere.c:      data->rt.img->clipable.clip_width
src/interface/context/add_sphere.c:      && data->itfc.mpos->y > data->rt.pos.y
src/interface/context/add_sphere.c:      && data->itfc.mpos->y < data->rt.pos.y +
src/interface/context/add_sphere.c:      data->rt.img->clipable.clip_height)
src/interface/context/add_sphere.c:      data->click_action = false;
src/interface/context/add_sphere.c:    data->click_action = false;
src/interface/context/basic_wallpaper.c:  pla->pos.x = 0;
src/interface/context/basic_wallpaper.c:  pla->pos.y = 0;
src/interface/context/basic_wallpaper.c:  pla->pos.z = 500000;
src/interface/context/basic_wallpaper.c:  pla->rot.x = 0;
src/interface/context/basic_wallpaper.c:  pla->rot.y = 0;
src/interface/context/basic_wallpaper.c:  pla->rot.z = 0;
src/interface/context/basic_wallpaper.c:  if (data->rt.obj != NULL)
src/interface/context/basic_wallpaper.c:    new = add_obj_elem_ret(data->rt.obj);
src/interface/context/basic_wallpaper.c:      data->rt.obj = create_obj_list();
src/interface/context/basic_wallpaper.c:      new = data->rt.obj;
src/interface/context/basic_wallpaper.c:  pla->tex_type = 1;
src/interface/context/basic_wallpaper.c:  pla->width = 5000;
src/interface/context/basic_wallpaper.c:  pla->height = 5000;
src/interface/context/basic_wallpaper.c:  pla->ka = 1.0;
src/interface/context/basic_wallpaper.c:  pla->kd = 1.0;
src/interface/context/basic_wallpaper.c:  pla->ks = 1.0;
src/interface/context/basic_wallpaper.c:  pla->brightness = 0.0;
src/interface/context/basic_wallpaper.c:  pla->reflection = 0.0;
src/interface/context/basic_wallpaper.c:  pla->opacity = 1.0;
src/interface/context/basic_wallpaper.c:  pla->color1.full = WHITE;
src/interface/context/basic_wallpaper.c:  pla->color2.full = BLACK;
src/interface/context/basic_wallpaper.c:  pla->case_size = 2000;
src/interface/context/basic_wallpaper.c:  new->datas = pla;
src/interface/context/basic_wallpaper.c:  new->type = PLANE;
src/interface/context/basic_wallpaper.c:  if (data->rt.img != NULL
src/interface/context/basic_wallpaper.c:      && data->click_action)
src/interface/context/basic_wallpaper.c:      data->click_action = false;
src/interface/context/basic_wallpaper.c:    data->click_action = false;
src/interface/context/gen_opt.c:  data->itfc.past.pos.x = FULL_PAST_X;
src/interface/context/gen_opt.c:  if (data->rt.width == FULL_WIDTH && data->rt.height == FULL_HEIGHT)
src/interface/context/gen_opt.c:    data->itfc.past.pos.y = FULL_PAST_Y;
src/interface/context/gen_opt.c:  else if (data->rt.width == HIGH_WIDTH && data->rt.height == HIGH_HEIGHT)
src/interface/context/gen_opt.c:    data->itfc.past.pos.y = FULL_PAST_Y + DECAL_PAST_FULLY * 1;
src/interface/context/gen_opt.c:  else if (data->rt.width == HD_WIDTH && data->rt.height == HD_HEIGHT)
src/interface/context/gen_opt.c:    data->itfc.past.pos.y = FULL_PAST_Y + DECAL_PAST_FULLY * 2;
src/interface/context/gen_opt.c:  else if (data->rt.width == XGA_WIDTH && data->rt.height == XGA_HEIGHT)
src/interface/context/gen_opt.c:    data->itfc.past.pos.y = FULL_PAST_Y + DECAL_PAST_FULLY * 3;
src/interface/context/gen_opt.c:  else if (data->rt.width == VGA_WIDTH && data->rt.height == VGA_HEIGHT)
src/interface/context/gen_opt.c:    data->itfc.past.pos.y = FULL_PAST_Y + DECAL_PAST_FULLY * 4;
src/interface/context/gen_opt.c:  mpos = data->itfc.mpos;
src/interface/context/gen_opt.c:  if (mpos->x > START_SLIDE_AA_X && mpos->x < END_SLIDE_AA_X
src/interface/context/gen_opt.c:      && mpos->y > START_SLIDE_AA_Y && mpos->y < END_SLIDE_AA_Y)
src/interface/context/gen_opt.c:    data->itfc.fct_bt_context = slide_aa;
src/interface/context/gen_opt.c:  else if (mpos->x > START_SLIDE_AMB_X && mpos->x < END_SLIDE_AMB_X
src/interface/context/gen_opt.c:      && mpos->y > START_SLIDE_AMB_Y && mpos->y < END_SLIDE_AMB_Y)
src/interface/context/gen_opt.c:    data->itfc.fct_bt_context = slide_amb;
src/interface/context/gen_opt.c:      if (mpos->x > CHOSE_SIZE_X
src/interface/context/gen_opt.c:	  && mpos->x < CHOSE_SIZE_X + CHOSE_SIZE_WDT
src/interface/context/gen_opt.c:	  && mpos->y > CHOSE_SIZE_Y + CHOSE_SIZE_DECAL_Y * i
src/interface/context/gen_opt.c:	  && mpos->y < CHOSE_SIZE_Y + CHOSE_SIZE_HGT + CHOSE_SIZE_DECAL_Y * i)
src/interface/context/gen_opt.c:	  data->itfc.fct_set_size[i](data);
src/interface/move_state.c:  if (data->rt.img != NULL)
src/interface/move_state.c:	  data->itfc.left_click = true;
src/interface/move_state.c:	  data->itfc.move.needmoving = false;
src/interface/move_state.c:	  data->itfc.left_click = false;
src/interface/move_state.c:	  data->itfc.move.needmoving = false;
src/live_engine/live_shade.c:  s->shade.inter.x = eye.x + s->hit.k1 * vct->x;
src/live_engine/live_shade.c:  s->shade.inter.y = eye.y + s->hit.k1 * vct->y;
src/live_engine/live_shade.c:  s->shade.inter.z = eye.z + s->hit.k1 * vct->z;
src/live_engine/live_shade.c:  s->shade.light_pos.x = light->pos.x;
src/live_engine/live_shade.c:  s->shade.light_pos.y = light->pos.y;
src/live_engine/live_shade.c:  s->shade.light_pos.z = light->pos.z;
src/live_engine/live_shade.c:  s->shade.vct.x = s->shade.inter.x - (double)s->shade.light_pos.x;
src/live_engine/live_shade.c:  s->shade.vct.y = s->shade.inter.y - (double)s->shade.light_pos.y;
src/live_engine/live_shade.c:  s->shade.vct.z = s->shade.inter.z - (double)s->shade.light_pos.z;
src/live_engine/live_shade.c:  it = s->obj;
src/live_engine/live_shade.c:      if (it->type == 1)
src/live_engine/live_shade.c:	  light = (t_light *)it->datas;
src/live_engine/live_shade.c:	  i += diffuse_light(s, s->obj_hit->next) * light->intensity * s->hit.kd;
src/live_engine/live_shade.c:      it = it->next;
src/live_engine/live_shade.c:  i += s->opt.ambient * s->hit.ka;
src/live_engine/live_shade.c:  s->final_color = apply_b(s->final_color, light_color, s->hit.brightness, i);
src/live_engine/display.c:    return (s->final_color);
src/live_engine/display.c:  s->ray.eye = eye;
src/live_engine/display.c:  s->ray.vct = vct;
src/live_engine/display.c:  order_hit_list(s->obj_hit);
src/live_engine/display.c:  if (s->obj_hit != NULL && s->obj_hit->next != NULL)
src/live_engine/display.c:      set_hit_values(s, s->obj_hit->next);
src/live_engine/display.c:      live_shade(s, s->ray.vct, s->ray.eye);
src/live_engine/display.c:      color = s->final_color;
src/live_engine/display.c:      clear_list(s->obj_hit);
src/live_engine/display.c:      s->obj_hit = NULL;
src/live_engine/display.c:  color = s->final_color;
src/live_engine/display.c:  /* if ((s->pixel_color = bunny_malloc(sizeof(t_color) * s->opt.aa)) == NULL) */
src/live_engine/display.c:  while (pos.y < s->height)
src/live_engine/display.c:      while (pos.x < s->width)
src/live_engine/display.c:	  vct.x = ((double)s->width / 2.0) - (double)pos.x;
src/live_engine/display.c:	  vct.y = ((double)s->height / 2.0) - (double)pos.y;
src/live_engine/display.c:	  rotation(&s->rotation, &vct, &s->eye.rot);
src/live_engine/display.c:	  final_color = live_display_objects(s, &vct, s->eye.pos, 0);
src/live_engine/display.c:	  mult_tekpixel(s->img, &pos, &final_color);
src/live_engine/display.c:  /* bunny_free(s->pixel_color); */
src/main/fill_pxlarray.c:  i = line - 1;
src/main/fill_pxlarray.c:  while (++i < pxar->clipable.clip_width
src/main/fill_pxlarray.c:      j = -1;
src/main/fill_pxlarray.c:      while (++j < pxar->clipable.clip_height)
src/main/fill_pxlarray.c:  j = -1;
src/main/fill_pxlarray.c:  while (++j < pxar->clipable.clip_height)
src/main/fill_pxlarray.c:      i = -1;
src/main/fill_pxlarray.c:      while (++i < pxar->clipable.clip_width)
src/main/delete_clipables.c:  if (data->rt.img != NULL)
src/main/delete_clipables.c:    bunny_delete_clipable(&data->rt.img->clipable);
src/main/delete_clipables.c:  if (data->ld.loading != NULL)
src/main/delete_clipables.c:    bunny_delete_clipable(&data->ld.loading->clipable);
src/main/delete_clipables.c:  if (data->itfc.layout != NULL)
src/main/delete_clipables.c:    bunny_delete_clipable(data->itfc.layout);
src/main/delete_clipables.c:  if (data->itfc.txt.font != NULL)
src/main/delete_clipables.c:    bunny_delete_clipable(data->itfc.txt.font);
src/main/delete_clipables.c:  if (data->itfc.past.img != NULL)
src/main/delete_clipables.c:    bunny_delete_clipable(data->itfc.past.img);
src/main/delete_clipables.c:  if (data->itfc.curs != NULL)
src/main/delete_clipables.c:    bunny_delete_clipable(data->itfc.curs);
src/main/delete_clipables.c:      if (data->itfc.context[i] != NULL)
src/main/delete_clipables.c:  	bunny_delete_clipable(data->itfc.context[i]);
src/main/delete_clipables.c:  if (data->rt.opt.skybox_right != NULL && data->rt.opt.skybox_left != NULL
src/main/delete_clipables.c:      && data->rt.opt.skybox_up != NULL
src/main/delete_clipables.c:      && data->rt.opt.skybox_down != NULL
src/main/delete_clipables.c:      && data->rt.opt.skybox_forward != NULL
src/main/delete_clipables.c:      && data->rt.opt.skybox_backward != NULL)
src/main/delete_clipables.c:      bunny_delete_clipable(&data->rt.opt.skybox_right->clipable);
src/main/delete_clipables.c:      bunny_delete_clipable(&data->rt.opt.skybox_up->clipable);
src/main/delete_clipables.c:      bunny_delete_clipable(&data->rt.opt.skybox_down->clipable);
src/main/delete_clipables.c:      bunny_delete_clipable(&data->rt.opt.skybox_left->clipable);
src/main/delete_clipables.c:      bunny_delete_clipable(&data->rt.opt.skybox_forward->clipable);
src/main/delete_clipables.c:      bunny_delete_clipable(&data->rt.opt.skybox_backward->clipable);
src/main/free.c:  bunny_free(data->itfc.save.file);
src/main/free.c:  bunny_free(data->itfc.open.file);
src/main/free.c:  j = -1;
src/main/init_main.c:  if ((data->win = bunny_start(WIN_WIDTH, WIN_HEIGHT,
src/main/init_main.c:  if ((data->ld.loading =
src/main/init_main.c:  fill_pxlarray(data->ld.loading, BLUE_LOAD);
src/main/init_main.c:  data->ld.pos.x = LOADING_X;
src/main/init_main.c:  data->ld.pos.y = LOADING_Y;
src/main/init_main.c:  data->ld.coef_load = 14.5;
src/main/init_main.c:  data->itfc.txt.win = data->win;
src/main/init_main.c:  data->wait_click = false;
src/main/init_main.c:  data->click_action = false;
src/main/init_main.c:  pos.x = (((MAX_WORK_SPACE_X - WORK_SPACE_X) / 2) + WORK_SPACE_X) -
src/main/init_main.c:    (rt->img->clipable.clip_width / 2);
src/main/init_main.c:  pos.y = (((MAX_WORK_SPACE_Y - WORK_SPACE_Y) / 2) + WORK_SPACE_Y) -
src/main/init_main.c:    (rt->img->clipable.clip_height / 2);
src/main/init_main.c:  rt->width = FULL_WIDTH;
src/main/init_main.c:  rt->height = FULL_HEIGHT;
src/main/init_main.c:  rt->img = NULL;
src/main/init_main.c:  rt->live = true;
src/main/init_main.c:  rt->coef_load = (float)rt->height / 100.0f;
src/main/init_main.c:  init_cos_sin(&rt->rotation);
src/main/init_main.c:  init_matrices(&rt->rotation);
src/main/init_main.c:  rt->obj = NULL;
src/main/init_main.c:      if ((rt->img = bunny_new_pixelarray(rt->width, rt->height)) == NULL)
src/main/init_main.c:      if (load_file(rt, argv[1]) == -1 ||
src/main/init_main.c:	  !(rt->pixel_color = bunny_malloc(sizeof(t_color) * rt->opt.aa)))
src/main/init_main.c:	return (-1);
src/main/init_main.c:      rt->pos = center_rt(rt);
src/main/init_main.c:      fill_pxlarray(rt->img, 0xFF262626);
src/main/init_main.c:  if ((ftabs->inters_ftab = bunny_malloc(sizeof(ftabs->inters_ftab) * 5)) == NULL)
src/main/init_main.c:  if ((ftabs->shadow_ftab = bunny_malloc(sizeof(ftabs->shadow_ftab) * 5)) == NULL)
src/main/init_main.c:  if ((ftabs->hit_ftab = bunny_malloc(sizeof(ftabs->hit_ftab) * 5)) == NULL)
src/main/init_main.c:  if ((ftabs->tex_ftab = bunny_malloc(sizeof(ftabs->tex_ftab) * 8)) == NULL)
src/main/setnbr.c:  i = -1;
src/main/setnbr.c:  p--;
src/main/setnbr.c:    clean[i++] = '-';
src/main/setnbr.c:      nbr = -nbr;
src/main/setnbr.c:    numb[p--] = ((nbr / (int)(pow(10, i++)) % 10) + '0');
src/main/setunsnbr.c:  i = -1;
src/main/setunsnbr.c:  p--;
src/main/setunsnbr.c:    numb[p--] = ((nbr / (int)(pow(10, i++)) % 10) + '0');
src/main/blit_clipables.c:  rt = &data->rt;
src/main/blit_clipables.c:  itfc = &data->itfc;
src/main/blit_clipables.c:  if (itfc->layout != NULL)
src/main/blit_clipables.c:    bunny_blit(&data->win->buffer, itfc->layout, 0);
src/main/blit_clipables.c:  bunny_blit(&data->win->buffer,
src/main/blit_clipables.c:	     itfc->context[itfc->act_context], &itfc->context_pos);
src/main/blit_clipables.c:  if (rt->img != NULL)
src/main/blit_clipables.c:    bunny_blit(&data->win->buffer, &rt->img->clipable /*&rt->opt.skybox_backward->clipable*/, &rt->pos);
src/main/blit_clipables.c:  if ((data->itfc.button[ADD_FORM] && data->itfc.past.pos.x != 0)
src/main/blit_clipables.c:      || (data->itfc.button[GEN_OPT] && data->itfc.past.pos.x != 0))
src/main/blit_clipables.c:    bunny_blit(&data->win->buffer, itfc->past.img, &itfc->past.pos);
src/main/blit_clipables.c:  if (data->itfc.button[GEN_OPT])
src/main/blit_clipables.c:      bunny_blit(&data->win->buffer, itfc->curs, &itfc->gen.pos_curs_aa);
src/main/blit_clipables.c:      bunny_blit(&data->win->buffer, itfc->curs, &itfc->gen.pos_curs_amb);
src/main/blit_clipables.c:  if ((data->ld.loading != NULL) &&
src/main/blit_clipables.c:    (data->itfc.rendered || data->itfc.rendering)
src/main/blit_clipables.c:      && !rt->live && !itfc->button[SAVE] && !itfc->button[OPEN]
src/main/blit_clipables.c:      && rt->r_pos.x != 0)
src/main/blit_clipables.c:    prerender(&data->rt, data->rt.r_pos.y, data);
src/main/put_base.c:  p--;
src/main/put_base.c:      num[i--] = base[nbr % base_len];
src/main/main.c:  data->mbutton = mbutton;
src/main/main.c:  data->mstate = state;
src/main/main.c:  if (data->wait_click && mbutton == BMB_LEFT && state == GO_DOWN)
src/main/main.c:      data->click_action = true;
src/main/main.c:      data->wait_click = false;
src/main/main.c:  if (data->rt.live)
src/main/main.c:    data->itfc.fct_state[data->itfc.status](data, state, mbutton);
src/main/main.c:      if (check_all_buttons(&data->itfc) == 1)
src/main/main.c:      if (check_button_activated(&data->itfc, data) == 1)
src/main/main.c:  if (data->rt.live)
src/main/main.c:  rt = &data->rt;
src/main/main.c:  itfc = &data->itfc;
src/main/main.c:  if (data->itfc.rendering)
src/main/main.c:    display(&data->rt, data);
src/main/main.c:      if (data->rt.live && data->rt.img != NULL)
src/main/main.c:	live_display(&data->rt);
src/main/main.c:  bunny_display(data->win);
src/main/main.c:  if (init_main_data(&data) == -1 ||
src/main/main.c:      init_engine_ftabs(&data.rt.ftabs) == -1 ||
src/main/main.c:      init_rt_data(&data.rt, argc, argv) == -1 ||
src/main/main.c:      init_itfc_data(&data.itfc, &data) == -1)
src/main/tekpixel.c:  col = (t_color *)pix->pixels;
src/main/tekpixel.c:  i = pix->clipable.clip_width * pos->y + pos->x;
src/main/tekpixel.c:  col = (t_color *)pix->pixels;
src/main/tekpixel.c:  i = pix->clipable.clip_width * pos->y + pos->x;
src/main/tekpixel.c:  i2 = pix->clipable.clip_width * (pos->y + 1) + pos->x;
src/main/tekpixel.c:  i3 = pix->clipable.clip_width * (pos->y + 2) + pos->x;
src/main/tekpixel.c:  i4 = pix->clipable.clip_width * (pos->y + 3) + pos->x;
src/solvers/second_order_solver.c:  res->delta = (res->b * res->b) - (4 * res->a * res->c);
src/solvers/second_order_solver.c:    res->root1 = -res->b / (2 * res->a);
src/solvers/second_order_solver.c:      res->root1 = (-res->b + sqrt(res->delta)) / (2 *res->a);
src/solvers/second_order_solver.c:      res->root2 = (-res->b - sqrt(res->delta)) / (2 *res->a);
